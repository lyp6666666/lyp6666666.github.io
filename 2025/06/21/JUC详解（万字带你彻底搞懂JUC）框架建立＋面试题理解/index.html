<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解 | lypのblog</title><meta name="author" content="实名上网陆熠鹏"><meta name="copyright" content="实名上网陆熠鹏"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解创建线程的三种方式 实现Runnable接口  创建一个类实现 Runnable 接口，并重写 run 方法。 Runnable 是一个函数式接口，只有一个抽象方法run。 使用示例： 12345public class MyThroad implements Runnable &#123;    @Override    public vo">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解">
<meta property="og:url" content="http://lypsblog.top/2025/06/21/JUC%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%87%E5%AD%97%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82JUC%EF%BC%89%E6%A1%86%E6%9E%B6%E5%BB%BA%E7%AB%8B%EF%BC%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E7%90%86%E8%A7%A3/index.html">
<meta property="og:site_name" content="lypのblog">
<meta property="og:description" content="JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解创建线程的三种方式 实现Runnable接口  创建一个类实现 Runnable 接口，并重写 run 方法。 Runnable 是一个函数式接口，只有一个抽象方法run。 使用示例： 12345public class MyThroad implements Runnable &#123;    @Override    public vo">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://lypsblog.top/img/java/java.png">
<meta property="article:published_time" content="2025-06-21T08:23:25.000Z">
<meta property="article:modified_time" content="2025-06-21T09:32:22.338Z">
<meta property="article:author" content="实名上网陆熠鹏">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lypsblog.top/img/java/java.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://lypsblog.top/2025/06/21/JUC%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%87%E5%AD%97%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82JUC%EF%BC%89%E6%A1%86%E6%9E%B6%E5%BB%BA%E7%AB%8B%EF%BC%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E7%90%86%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-21 17:32:22'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Learning notes</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/machine-learning/"><span> Machine-learning</span></a></li><li><a class="site-page child" href="/java/"><span> Java</span></a></li><li><a class="site-page child" href="/springboot/"><span> Springboot</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/java/java.png')"><nav id="nav"><span id="blog-info"><a href="/" title="lypのblog"><span class="site-name">lypのblog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Learning notes</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/machine-learning/"><span> Machine-learning</span></a></li><li><a class="site-page child" href="/java/"><span> Java</span></a></li><li><a class="site-page child" href="/springboot/"><span> Springboot</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-06-21T08:23:25.000Z" title="Created 2025-06-21 16:23:25">2025-06-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-06-21T09:32:22.338Z" title="Updated 2025-06-21 17:32:22">2025-06-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解"><a href="#JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解" class="headerlink" title="JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解"></a>JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解</h1><h2 id="创建线程的三种方式"><a href="#创建线程的三种方式" class="headerlink" title="创建线程的三种方式"></a>创建线程的三种方式</h2><ol>
<li><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3></li>
</ol>
<p>创建一个类实现 Runnable 接口，并重写 run 方法。</p>
<p><code>Runnable</code> 是一个函数式接口，只有一个抽象方法run。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThroad</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><h3 id="继承Thread-类"><a href="#继承Thread-类" class="headerlink" title="继承Thread 类"></a>继承Thread 类</h3></li>
</ol>
<p><strong>Thread本身也是实现了<strong><strong>Runnable</strong></strong>接口:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过构造函数，<code>Thread</code> 可以接受一个 <code>Runnable</code> 对象作为参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t = new Thread(new MyRunnable());</span><br></pre></td></tr></table></figure>

<p>这种方式<strong>将任务和线程****解耦</strong>，推荐使用。</p>
<p>使用示例：创建一个类继承 Thread 类，并重写 run 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-实现Callable接口"><a href="#3-实现Callable接口" class="headerlink" title="3.实现Callable接口"></a>3.实现Callable接口</h3><p>实现 Callable 接口，重写 call 方法，这种方式可以通过 FutureTask 获取任务执行的返回值。</p>
<h2 id="控制线程的方法"><a href="#控制线程的方法" class="headerlink" title="控制线程的方法"></a>控制线程的方法</h2><ol>
<li><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3></li>
</ol>
<p>使当前<strong>正在执行的线程</strong>暂停指定的毫秒数，也就是进入休眠的状态。</p>
<p>需要注意的是，sleep 的时候要对异常进行处理。</p>
<ol>
<li><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3></li>
</ol>
<p>等待这个线程执行完才会轮到后续线程得到 cpu 的执行权，使用这个也要捕获异常。</p>
<ol>
<li><h3 id="setDaemen"><a href="#setDaemen" class="headerlink" title="setDaemen()"></a>setDaemen()</h3></li>
</ol>
<p>将此线程标记为守护，准确来说，就是服务其他的线程，像 Java 中的垃圾回收线程，就是典型的守护线程。</p>
<ol>
<li><h3 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h3></li>
</ol>
<p>yield() 方法是一个静态方法，用于暗示当前线程愿意放弃其当前的时间片，允许其他线程执行。然而，它只是向线程调度器提出建议，调度器可能会忽略这个建议。具体行为取决于操作系统和 JVM 的线程调度策略。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/java/JUC/1.jpg" alt="1"></p>
<h2 id="获取Java线程的执行结果：Callable、Future和Future-Task"><a href="#获取Java线程的执行结果：Callable、Future和Future-Task" class="headerlink" title="获取Java线程的执行结果：Callable、Future和Future Task"></a>获取Java线程的执行结果：Callable、Future和Future Task</h2><p>Runnable中的run()方法的返回值的void</p>
<p>所以在执行完任务后无法返回任何结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Callable是有返回值的"><a href="#Callable是有返回值的" class="headerlink" title="Callable是有返回值的"></a>Callable是有返回值的</h3><p>Callable 位于 <code>java.util.concurrent</code> 包下，也是一个接口，它定义了一个 <code>call()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般会配合ExecutorService来配合使用,</p>
<p>ExecutorService是一个接口，位于java.util.concurrent包下，它是Java线程池框架的核心接口，用来异步执行任务，它提供了一些关键方法来进行线程管理。</p>
<p>Ex:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个包含5个线程的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Callable任务</span></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello from &quot;</span> + Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务到ExecutorService执行，并获取Future对象</span></span><br><span class="line">Future[] futures = <span class="keyword">new</span> <span class="title class_">Future</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    futures[i] = executorService.submit(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Future对象获取任务的结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(futures[i].get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭ExecutorService，不再接受新的任务，等待所有已提交的任务完成</span></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>

<h3 id="异步计算结果的-Future-接口"><a href="#异步计算结果的-Future-接口" class="headerlink" title="异步计算结果的 Future 接口"></a>异步计算结果的 Future 接口</h3><p>在之前的例子中，使用了一个Future 来获取 Callable任务的执行结果，</p>
<p>Future 位于 java.util.concurrent 包下，它是一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一共声明了 5 个方法：</p>
<ul>
<li><code>cancel()</code> 方法用来取消任务，如果取消任务成功则返回 true，如果取消任务失败则返回 false。参数 mayInterruptIfRunning 表示是否允许取消正在执行却没有执行完毕的任务，如果设置 true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论 mayInterruptIfRunning 为 true 还是 false，此方法肯定返回 false，即如果取消已经完成的任务会返回 false；如果任务正在执行，若 mayInterruptIfRunning 设置为 true，则返回 true，若 mayInterruptIfRunning 设置为 false，则返回 false；如果任务还没有执行，则无论 mayInterruptIfRunning 为 true 还是 false，肯定返回 true。</li>
<li><code>isCancelled()</code> 方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li>
<li><code>isDone()</code> 方法表示任务是否已经完成，若任务完成，则返回 true；</li>
<li><code>get()</code>方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li>
<li><code>get(long timeout, TimeUnit unit)</code>用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回 null。</li>
</ul>
<p>也就是说Future可以：</p>
<ol>
<li>判断任务是否完成</li>
<li>能够中断任务</li>
<li>能够获取任务执行结果</li>
</ol>
<p>由于Future 只是一个接口，如果直接 new 的话会有一个警告，提醒我们最好使用 FtureTask。</p>
<p>实际上，FutureTask 是 Future 接口的一个唯一实现类，我们在前面的例子中 <code>executorService.submit()</code> 返回的就是 FutureTask。</p>
<h3 id="异步计算结果-FutureTask-实现类"><a href="#异步计算结果-FutureTask-实现类" class="headerlink" title="异步计算结果 FutureTask 实现类"></a>异步计算结果 FutureTask 实现类</h3><p>我们来看一下 FutureTask 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt;</span><br></pre></td></tr></table></figure>

<p>FutureTask 类实现了 RunnableFuture 接口，我们看一下 RunnableFuture 接口的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 RunnableFuture 继承了 Runnable 接口和 Future 接口，而 FutureTask 实现了 RunnableFuture 接口。所以它既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值。</p>
<p>FutureTask 提供了两个构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Runnable runnable, V result)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java线程的六种状态"><a href="#Java线程的六种状态" class="headerlink" title="Java线程的六种状态"></a>Java线程的六种状态</h2><p>Thread.State 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h3><p>处于NEW状态的线程尚未启动，即还没有调用Thread实例的start()方法。</p>
<p>两个引申问题：</p>
<ol>
<li>反复调用同一个线程的 start 方法是否可行？<ol>
<li>不行，在调用 start 之后，threadStatus 的值会改变（<code>threadStatus !=0</code>），再次调用 start 方法会抛出 IllegalThreadStateException 异常。</li>
</ol>
</li>
<li>假如一个线程执行完毕（此时处于 TERMINATED 状态），再次调用这个线程的 start 方法是否可？<ol>
<li>不行，threadStatus 为 2 代表当前线程状态为 TERMINATED</li>
</ol>
</li>
</ol>
<h3 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h3><p>表示正在运行中的线程，处于RUNNNABLE状态中的线程可能正在执行也可能正在等待CPU分配资源。</p>
<p>Java 线程的RUNNABLE状态其实包括了操作系统线程的ready和running两个状态。</p>
<h3 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h3><p>阻塞状态。处于 BLOCKED 状态的线程正等待锁（锁会在后面细讲）的释放以进入同步区。</p>
<h3 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h3><p>等待状态。处于等待状态的线程编程RUNNABLE需要其他线程的唤醒。</p>
<p>调用下面这三个方法会使线程进去等待状态：</p>
<ul>
<li><code>Object.wait()</code>：使当前线程处于等待状态直到另一个线程唤醒它；</li>
<li><code>Thread.join()</code>：等待线程执行完毕，底层调用的是 Object 的 wait 方法；</li>
<li><code>LockSupport.park()</code>：除非获得调用许可，否则禁用当前线程进行线程调度。</li>
</ul>
<h3 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h3><p>超时等待时间。线程等待一个具体的时间，时间到后会被自动唤醒。</p>
<p>调用如下方法会使线程进入超时等待状态：</p>
<ul>
<li><code>Thread.sleep(long millis)</code>：使当前线程睡眠指定时间；</li>
<li><code>Object.wait(long timeout)</code>：线程休眠指定时间，等待期间可以通过<code>notify()</code>&#x2F;<code>notifyAll()</code>唤醒；</li>
<li><code>Thread.join(long millis)</code>：等待当前线程最多执行 millis 毫秒，如果 millis 为 0，则会一直执行；</li>
<li><code>LockSupport.parkNanos(long nanos)</code>： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；</li>
<li><code>LockSupport.parkUntil(long deadline)</code>：同上，也是禁止线程进行调度指定时间</li>
</ul>
<h3 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h3><p>终止状态。线程已执行完毕</p>
<h2 id="Java的内存模型-JMM"><a href="#Java的内存模型-JMM" class="headerlink" title="Java的内存模型(JMM)"></a>Java的内存模型(JMM)</h2><p>JMM定义了Java程序中的变量、线程如何和主存以及工作内存进行交互的规则。它主要涉及到多线程环境下的共享变量可见性、指令重排等问题。其主要目的是为了解决由于编译器优化、处理器优化和缓存系统等导致的<strong>可见性</strong>、<strong>原子性</strong>和<strong>有序性</strong>。</p>
<p>内存可见性问题：</p>
<p>是指 <strong>在<strong><strong>多线程</strong></strong>环境下，一个线程对共享变量的修改，另一个线程无法立即（或永远无法）看到最新值</strong>，导致程序出现不符合预期的行为。</p>
<p>并发编程的线程之间存在两个问题：</p>
<ul>
<li>线程间如何通信：即线程之间以何种机制来交换信息</li>
<li>线程间如何同步：线程以何种机制来控制不同线程之间发生的相对顺序</li>
</ul>
<p>有两种模型可以解决这两个问题：</p>
<ul>
<li>消息传递并发模型</li>
<li>共享内存并发模型</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>如何通信</th>
<th>如何同步</th>
</tr>
</thead>
<tbody><tr>
<td>消息传递并发模型</td>
<td>线程之间没有公共状态，线程间的通信必须通过发送消息来显示进行通信。</td>
<td>发送消息天然同步，因为发送消息总是在接受消息之前，因此同步是隐式的。</td>
</tr>
<tr>
<td>共享内存并发模型</td>
<td>线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。</td>
<td>必须显式指定某段代码需要在线程之间互斥执行，同步是显式的。</td>
</tr>
</tbody></table>
<p>而java使用的是<strong>共享内存</strong>模型</p>
<p>观察运行时数据区域，只有方法区和堆是所有线程共享的，内存可见性针对的就是堆中的共享变量。</p>
<h3 id="既然堆是共享的，为什么在堆中会有内存不可见问题？"><a href="#既然堆是共享的，为什么在堆中会有内存不可见问题？" class="headerlink" title="既然堆是共享的，为什么在堆中会有内存不可见问题？"></a>既然堆是共享的，为什么在堆中会有内存不可见问题？</h3><p>因为每个线程都有<strong>自己的本地****内存</strong>，而这些本地内存中的变量值与<strong>主内存</strong>之间可能不同步。</p>
<p><strong>本地<strong><strong>内存</strong></strong>：</strong></p>
<p>本地内存（Working Memory）是 Java 内存模型（JMM）的一个<strong>抽象概念</strong>，并不是真实存在的硬件结构。</p>
<ul>
<li>每个线程都有<strong>自己的本地****内存</strong>，它是线程的<strong>私有空间</strong>。</li>
<li>本地内存中保存了<strong>主内存中的共享变量的副本</strong>，以提高访问速度。</li>
<li>本地内存包括：<ul>
<li><strong>CPU</strong> <strong>寄存器</strong>：存放临时计算结果或中间值。</li>
<li><strong>CPU</strong> <strong>缓存（如 L1、L2、L3 缓存）</strong>：加速主存访问。</li>
<li><strong>编译器优化后的缓存（如</strong> <strong>JIT</strong> <strong>优化存储区）</strong>：JIT 编译器在运行时做出的性能优化。</li>
</ul>
</li>
</ul>
<p>Java 线程之间的通信由 Java 内存模型（简称 JMM）控制，从抽象的角度来说，JMM 定义了线程和主存之间的抽象关系：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/java/JUC/2.png" alt="2"></p>
<ol>
<li>所有共享变量都存在主存当中。</li>
<li>每个线程都保存了一份该线程使用到的共享变量的副本。</li>
<li>如果线程A与线程B之间要通信的话：<ol>
<li>线程 A 将本地内存 A 中更新过的共享变量刷新到主存中去。</li>
<li>线程 B 到主存中去读取线程 A 之前已经更新过的共享变量。</li>
</ol>
</li>
</ol>
<p>所以，线程A无法直接访问线程B的工作内容，线程间通信必须经过主存。</p>
<p>注意：根据JMM的规定，<strong>线程对共享变量的所有操作都必须在自己的本地<strong><strong>内存</strong></strong>中进行，任何对共享变量的读、写操作，必须先把值拷贝到线程的本地内存中，然后进行操作。</strong></p>
<h3 id="如何保证内存可见性？"><a href="#如何保证内存可见性？" class="headerlink" title="如何保证内存可见性？"></a>如何保证内存可见性？</h3><p>JMM 通过控制主存与每个线程的本地内存之间的交互，来提供内存可见性保证。</p>
<p>Java 内存模型 (JMM) 主要针对的是多线程环境下，如何在主内存与工作内存之间安全地执行操作。</p>
<p>Java 中的 volatile 关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序，synchronized 关键字不仅保证可见性，同时也保证了原子性（互斥性）。</p>
<h3 id="JMM与重排序"><a href="#JMM与重排序" class="headerlink" title="JMM与重排序"></a>JMM与重排序</h3><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排</p>
<p>重排序在是线上分为以下三种类型</p>
<ul>
<li><strong>编译器优化重排序</strong>：JIT 编译时调整指令顺序。</li>
<li><strong>CPU</strong> <strong>指令****级重排序</strong>：CPU 执行时调整顺序，现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。</li>
<li><strong>内存****系统重排序</strong>：多核 CPU 缓存一致性问题。</li>
</ul>
<p>指令重排对于提高 CPU 性能十分必要，但也带来了乱序的问题。所以在多线程下，指令重排序可能会导致<strong>有序性</strong>问题。</p>
<h3 id="JMM与-happens-before"><a href="#JMM与-happens-before" class="headerlink" title="JMM与 happens-before"></a>JMM与 happens-before</h3><p>Happens-Before 是 JMM 中的一个核心原则，用来判断两个操作之间的先后顺序（可见性和有序性）。如果一个操作 <strong>A</strong> Happens-Before 另一个操作 <strong>B</strong>，那么操作 <strong>A</strong> 的结果对操作 <strong>B</strong> 可见。</p>
<p><strong>Happens-Before 的主要规则</strong>：</p>
<ol>
<li><p><strong>程序次序规则（Program Order Rule）：</strong></p>
<ol>
<li>在同一个线程中，按照程序的控制流顺序，前面的操作 Happens-Before 后面的操作。</li>
<li>例如：在同一线程中，语句 <code>int x = 1; int y = 2;</code>，<code>x=1</code> Happens-Before <code>y=2</code>。</li>
</ol>
</li>
<li><p><strong>监视器锁规则（Monitor Lock Rule）：</strong></p>
<ol>
<li>解锁（unlock）一个监视器锁 Happens-Before 随后加锁（lock）同一监视器锁。</li>
<li>例如：一个线程释放锁之后，另一个线程获取该锁，则释放锁的操作对获取锁的线程是可见的。</li>
</ol>
</li>
<li><p><strong>volatile 变量规则（Volatile Variable Rule）：</strong></p>
<ol>
<li>对一个 <code>volatile</code> 变量的写操作 Happens-Before 后续对该 <code>volatile</code> 变量的读操作。</li>
<li>例如：<code>volatile int x = 0; x = 1; int y = x;</code>，写操作 <code>x = 1</code> Happens-Before 读操作 <code>int y = x;</code>。</li>
</ol>
</li>
<li><p><strong>传递性（Transitivity）：</strong></p>
<ol>
<li>如果操作 <strong>A</strong> Happens-Before 操作 <strong>B</strong>，且操作 <strong>B</strong> Happens-Before 操作 <strong>C</strong>，则操作 <strong>A</strong> Happens-Before 操作 <strong>C</strong>。</li>
<li>例如：如果 <code>A -&gt; B</code>，且 <code>B -&gt; C</code>，则 <code>A -&gt; C</code>。</li>
</ol>
</li>
<li><p><strong>线程启动规则（Thread Start Rule）：</strong></p>
<ol>
<li>主线程调用 <code>Thread.start()</code> 之后，子线程中的任何操作都 Happens-Before 该 <code>start()</code> 方法返回。<ul>
<li><pre><code class="Java">Thread t = new Thread(() -&gt; x = 1);
t.start();
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   2. `t.start()` Happens-Before 子线程的操作。</span><br><span class="line"></span><br><span class="line">1. **线程终止规则（Thread Join Rule）：**</span><br><span class="line">   1. 如果线程 **A** 执行 `Thread.join()` 并成功返回，则线程 **B** 中的所有操作 Happens-Before 线程 **A** 从 `join()` 方法返回。</span><br><span class="line">      - ```Java</span><br><span class="line">        t.join();</span><br><span class="line">        int y = x;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li>如果子线程完成，<code>t.join()</code> Happens-Before <code>int y = x;</code>。</li>
</ol>
</li>
<li><p><strong>对象终结规则（Finalizer Rule）：</strong></p>
<ol>
<li>一个对象的构造函数执行结束 Happens-Before 该对象的 <code>finalize()</code> 方法。</li>
</ol>
</li>
</ol>
<h3 id="Happens-Before-的作用"><a href="#Happens-Before-的作用" class="headerlink" title="Happens-Before 的作用"></a>Happens-Before 的作用</h3><ul>
<li><strong>保证可见性：</strong> 确保一个操作对其他线程是可见的。</li>
<li><strong>保证有序性：</strong> 规定操作的先后顺序，避免重排序导致的数据不一致。</li>
<li><strong>确保<strong><strong>线程安全</strong></strong>：</strong> 在并发编程中，通过正确使用 Happens-Before 规则，可以确保程序的正确性。</li>
</ul>
<h2 id="Java-volatile关键字"><a href="#Java-volatile关键字" class="headerlink" title="Java volatile关键字"></a>Java volatile关键字</h2><p>在 Java 中，<code>volatile</code> 是一种<strong>关键字</strong>，用于修饰<strong>变量</strong>，确保该变量在多个线程之间的<strong>可见性</strong>和<strong>有序性</strong>。</p>
<p>当我们使用 volatile 关键字来修饰一个变量时，Java 内存模型会插入内存屏障（一个处理器指令，可以对 CPU 或编译器重排序做出约束）来确保以下两点：</p>
<ul>
<li>写屏障（Write Barrier）：当一个 volatile 变量被写入时，写屏障确保在该屏障之前的所有变量的写入操作都提交到主内存。</li>
<li>读屏障（Read Barrier）：当读取一个 volatile 变量时，读屏障确保在该屏障之后的所有读操作都从主内存中读取。</li>
</ul>
<p>也就是说，使用 volatile 关键字修饰共享变量可以禁止重排序。即保证了<strong>有序性</strong></p>
<p>当一个线程修改了volatile变量的值，新值会立即被刷新到主内存中，其他线程再读取该变量时可以立即获得最新值。即保证了<strong>可见性</strong></p>
<h3 id="volatile-可以实现单例模式的双重锁"><a href="#volatile-可以实现单例模式的双重锁" class="headerlink" title="volatile 可以实现单例模式的双重锁"></a>volatile 可以实现单例模式的双重锁</h3><p>在单例模式中，volatile 可以防止指令重排序，从而避免未初始化的对象被使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 使用 volatile 确保可见性和有序性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 2. 私有构造方法，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 3. 获取单例实例的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次检查：避免不必要的同步</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 同步代码块，防止并发创建</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  <span class="comment">// 加锁，确保线程安全</span></span><br><span class="line">                <span class="comment">// 第二次检查：防止多个线程同时创建实例</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，使用volatile关键字是为了防止<code>instance = new Singleton();</code>这一步被指令重排。因为实际上，<code>new Singleton()</code> 这一行代码分为三个步骤：</p>
<ol>
<li>为 <code>Singleton</code>对象分配足够的内存空间</li>
<li>调用<code>Singleton</code> 的构造方法，初始化对象的成员变量</li>
<li>将内存地址赋值给<code>instance</code> 变量,使其指向新创建的对象</li>
</ol>
<p>如果不使用 voltile 关键字，JVM 和 CPU 可能会对这三个步骤进行指令重排，将上述的第二第三步骤相反，导致线程读取到部分未初始化的 <code>Singleton</code> 对象。</p>
<h2 id="Java-synchronized-关键字"><a href="#Java-synchronized-关键字" class="headerlink" title="Java synchronized 关键字"></a>Java synchronized 关键字</h2><p>用于<strong>解决<strong><strong>多线程</strong></strong>并发问题</strong>，它通过<strong>加锁和解锁机制</strong>来保证线程之间的<strong>同步、<strong><strong>互斥</strong></strong>和原子性</strong>。</p>
<p>关键字 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块。</p>
<p>同时，synchronized 还可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代 volatile 功能）</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p><code>synchronized</code> 关键字具备以下三个主要特性：</p>
<ol>
<li><strong>原子性（Atomicity）</strong>：操作在执行过程中<strong>不可中断</strong>，即<strong>独占执行</strong>。</li>
<li><strong>可见性（Visibility）</strong>：一个线程修改了共享变量，其他线程<strong>立即可见</strong>。</li>
<li><strong>有序性（Orderliness）</strong>：由于内存屏障，<strong>指令****重排序</strong>被禁止。</li>
</ol>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ol>
<li><h4 id="修饰实例方法（锁为当前实例对象）"><a href="#修饰实例方法（锁为当前实例对象）" class="headerlink" title="修饰实例方法（锁为当前实例对象）"></a>修饰实例方法（锁为当前实例对象）</h4></li>
</ol>
<p>通过在方法声明中加入 synchronized 关键字，可以保证在任意时刻，只有一个线程能执行该方法。</p>
<p>特点：</p>
<ul>
<li><strong>锁对象：</strong> 当前实例对象 (<code>this</code>)。</li>
<li><strong>作用范围：</strong> 整个方法。</li>
<li><strong>适用场景：</strong> 保证实例方法的<strong>线程安全性</strong>。</li>
</ul>
<ol>
<li><h4 id="修饰静态方法（锁为当前类对象）"><a href="#修饰静态方法（锁为当前类对象）" class="headerlink" title="修饰静态方法（锁为当前类对象）"></a>修饰静态方法（锁为当前类对象）</h4></li>
</ol>
<p>当 <code>synchronized</code> 修饰<strong>静态方法</strong>时，锁定的是<strong>当前类对象（Class对象）</strong>。</p>
<ol>
<li><h4 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h4></li>
</ol>
<p><strong>精确控制同步范围</strong>，提高性能。</p>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>synchronized 实现原理依赖于 JVM 的 Monitor(监视器锁)和 对象头(Object Header)当 synchronized 修饰在方法或代码块上时，会对特定的对象或类加锁，从而确保同一时刻只有一个线程能执行加锁的代码安</p>
<ul>
<li><strong>synchronized 修饰方法</strong>:会在方法的访问标志中增加一个 ACCSYNCHRONIZED 标志。每当一个线程访问该方法时，JVM会检查方法的访问标志。如果包含 ACCSYNCHRONIZED 标志，线程必须先获得该方法对应的对象的监视器锁(即对象锁)，然后才能执行该方法，从而保证方法的同步性。</li>
<li><strong>synchronized 修饰代码块</strong>:会在代码块的前后插入 monitorenter和 monitorexit 字节码指令。可以把 monitorenter理解为加锁， monitorexit 理解为解锁。</li>
</ul>
<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 对象监视器 <code>monitor</code> 的持有权</p>
<p>在JVM中，Monitor 是基于 C++实现的。每个对象中都内置了一个<code>ObjectMonitor</code>对象。</p>
<p>Monitor：</p>
<ol>
<li>保证在同一时刻，只有一个线程能够访问临界区代码</li>
<li>管理线程之间的同步与协作（如等待和通知）</li>
</ol>
<p>而<code>ObjectMonitor</code>就是Monitor 的具体实现。</p>
<h2 id="Synchronized-锁的到底是什么，偏向锁、轻量级锁、重量级锁"><a href="#Synchronized-锁的到底是什么，偏向锁、轻量级锁、重量级锁" class="headerlink" title="Synchronized 锁的到底是什么，偏向锁、轻量级锁、重量级锁"></a>Synchronized 锁的到底是什么，偏向锁、轻量级锁、重量级锁</h2><p><strong>首先，Java</strong> <strong>多线程****的锁都是基于对象的，Java中的每一个对象都可以作为一个锁</strong></p>
<p>类锁，也就是Class对象的锁</p>
<ul>
<li><strong>每个 Java 对象</strong>都可以作为锁（也叫<strong>监视器锁</strong>）。</li>
<li>，通过 Synchronized 实现的都是<strong>内置锁</strong> ，内置锁有偏向锁、轻量级锁、重量级锁这些状态，这些锁机制都通过<strong>对象头</strong>中的<strong>Mark Word</strong>来体现。</li>
</ul>
<h3 id="内置锁的四种状态及锁降级"><a href="#内置锁的四种状态及锁降级" class="headerlink" title="内置锁的四种状态及锁降级"></a>内置锁的四种状态及锁降级</h3><p>在 JDK 1.6 以前，所有的锁都是“重量级”锁，因为使用的都是操作系统的互斥锁，当一个线程持有锁时，其他企图进入synchronized 块的线程将被阻塞，直到锁被释放。涉及到了线程上下文切换和用户态和内核态的切换，因此效率低。</p>
<p>为了<strong>减少获得锁和释放锁带来的性能消耗</strong>，在 JDK 1.6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是：</p>
<ol>
<li>无锁状态</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态</li>
</ol>
<p>几种锁会随着竞争情况逐渐升级，锁的升级很容易发生，但是锁降级发生的条件就比较苛刻了，锁降级发生在 Stop The World 期间，当 JVM 进入安全点的时候，会检查是否有闲置的锁，然后进行降级。</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>
<td>适用于只有一个线程访问同步块场景。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度。</td>
<td>如果始终得不到锁竞争的线程使用自旋会消耗 CPU。</td>
<td>追求响应时间。同步块执行速度非常快。</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗 CPU。</td>
<td>线程阻塞，响应时间缓慢。</td>
<td>追求吞吐量。同步块执行时间较长。</td>
</tr>
</tbody></table>
<p>来自《Java 并发编程的艺术》</p>
<h3 id="对象的锁放在什么地方"><a href="#对象的锁放在什么地方" class="headerlink" title="对象的锁放在什么地方"></a>对象的锁放在什么地方</h3><p>每个 Java 对象都有一个对象头。如果是非数组类型，则用 2 个字宽来存储对象头，如果是数组，则会用 3 个字宽来存储对象头。在 32 位处理器中，一个字宽是 32 位；在 64 位虚拟机中，一个字宽是 64 位。ku</p>
<p>对象头的组成：</p>
<ul>
<li><strong>Mark Word（标记字段）：</strong> 存储对象的<strong>运行时状态</strong>信息。</li>
<li><strong>Class Pointer（类型指针）：</strong> 指向<strong>类元数据</strong>，表示对象是哪个类的实例。</li>
<li><strong>数组长度（仅数组对象拥有）：</strong> 存储数组长度。</li>
</ul>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁用于<strong>减少线程反复获取和释放锁的开销</strong>，尤其是在<strong>同一线程多次获取相同锁</strong>的场景中（如单线程环境）。</p>
<p>在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，所以引入了偏向锁。</p>
<p><strong>实现原理：</strong></p>
<ol>
<li>加锁：<ol>
<li>当一个线程第一次获取锁时，在对象头的<strong>Mark Word</strong>中存储线程 ID，表示<strong>该对象偏向该线程</strong>。</li>
<li>以后该线程再次获取锁时，只需检查对象头的线程 ID 是否与当前线程匹配，无需加锁和解锁操作。(优化性能)</li>
</ol>
</li>
<li>撤销偏向:<ol>
<li>如果<strong>另一个线程</strong>尝试获取偏向锁，则需要<strong>撤销偏向</strong>。此时会暂停当前持有偏向锁的线程，将锁状态升级为<strong>轻量级锁</strong>。</li>
</ol>
</li>
</ol>
<p>适合场景：</p>
<p>适合<strong>单线程场景</strong>，如代码块在大部分情况下只被一个线程访问。</p>
<p>性能优势：</p>
<ul>
<li><strong>消除<strong><strong>CAS</strong></strong>操作：</strong> 只需检查线程 ID，避免了重量级加锁操作。</li>
<li><strong>减少上下文切换：</strong> 线程不竞争时，几乎无性能损耗。</li>
</ul>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁用于<strong>减少重量级锁的开销</strong>，特别是在<strong>短时间内不会发生线程竞争</strong>的场景。</p>
<p><strong>实现原理：</strong></p>
<ol>
<li><strong>加锁：</strong><ol>
<li>线程尝试获取轻量级锁时，会<strong>在当前线程栈中创建一个 Lock Record</strong>，并将对象头的<strong>Mark Word</strong>复制到该 Lock Record 中。</li>
<li>使用<strong>CAS****操作</strong>将对象头的 Mark Word 指向 Lock Record，表示加锁成功。</li>
</ol>
</li>
<li><strong>锁膨胀：</strong><ol>
<li>如果有其他线程竞争该锁，轻量级锁会升级为<strong>重量级锁</strong>。</li>
<li>轻量级锁的持有线程和竞争线程都会进入<strong>阻塞状态</strong>，导致上下文切换。</li>
</ol>
</li>
</ol>
<p>适用场景：</p>
<p>适合<strong>短时间内不存在激烈竞争</strong>的情况，比如<strong>加锁代码执行时间较短</strong>。</p>
<p>性能优势：</p>
<ul>
<li><strong>减少阻塞：</strong> 在无竞争情况下使用<strong>自旋</strong>而非挂起，提高性能。</li>
<li><strong>快速解锁：</strong> 线程退出同步块时，使用<strong>CAS****操作</strong>恢复 Mark Word，无需操作操作系统级别的互斥锁。</li>
</ul>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>它是一种<strong>低效但稳妥</strong>的加锁方式，适用于<strong>线程竞争激烈</strong>的场景。</p>
<p>特点：</p>
<ol>
<li><strong>阻塞与唤醒：</strong></li>
</ol>
<ul>
<li>当线程无法获取重量级锁时，<strong>进入阻塞状态</strong>，操作系统会<strong>挂起线程</strong>，而不是自旋等待。</li>
<li>当持有锁的线程释放锁时，阻塞线程会被<strong>唤醒</strong>，导致<strong>上下文切换</strong>。</li>
</ul>
<ol>
<li><strong>基于<strong><strong>操作系统</strong></strong>的同步机制：</strong></li>
</ol>
<ul>
<li>重量级锁使用操作系统互斥量（Mutex）来进行线程同步。</li>
<li><strong>线程切换</strong>依赖于操作系统内核态和用户态的切换，成本较高。</li>
</ul>
<ol>
<li><strong>Monitor机制：</strong></li>
</ol>
<ul>
<li>每个 Java 对象都有一个监视器（Monitor）与之关联，重量级锁基于监视器实现。</li>
<li>当线程获取锁时，Monitor 会将<strong>对象头中的 Mark Word</strong>替换为指向<strong>Monitor对象的指针</strong>。</li>
</ul>
<p>实现原理：</p>
<h4 id="加锁过程："><a href="#加锁过程：" class="headerlink" title="加锁过程："></a>加锁过程：</h4><ol>
<li>当线程尝试获取锁时：<ol>
<li>如果锁为空闲状态，则<strong>直接持有锁</strong>，将 Mark Word 指向 Monitor。</li>
<li>如果已经被其他线程持有，线程会进入<strong>阻塞队列</strong>。</li>
</ol>
</li>
<li><strong>阻塞与唤醒：</strong><ol>
<li>持有锁的线程完成同步代码块后，会<strong>释放锁</strong>，并通过<strong>操作系统****信号机制</strong>唤醒阻塞线程。</li>
<li>阻塞的线程会重新竞争获取锁。</li>
</ol>
</li>
</ol>
<h4 id="解锁过程："><a href="#解锁过程：" class="headerlink" title="解锁过程："></a>解锁过程：</h4><ul>
<li>当线程退出同步代码块时：<ul>
<li>直接释放 Monitor，唤醒<strong>阻塞队列中的第一个线程</strong>。</li>
<li>解锁后，线程上下文切换。</li>
</ul>
</li>
</ul>
<h3 id="锁升级和降级"><a href="#锁升级和降级" class="headerlink" title="锁升级和降级"></a>锁升级和降级</h3><p>在Java中，锁可以逐步升级，但是很难降级</p>
<p>升级触发条件：</p>
<ul>
<li><strong>偏向锁 → 轻量级锁：</strong> 当<strong>另一个线程</strong>尝试获取偏向锁时。</li>
<li><strong>轻量级锁 → 重量级锁：</strong> 轻量级锁自旋次数过多或<strong>竞争线程过多</strong>时。</li>
</ul>
<h4 id="升级的具体流程："><a href="#升级的具体流程：" class="headerlink" title="升级的具体流程："></a>升级的具体流程：</h4><p>每一个线程在准备获取共享资源时：</p>
<h4 id="第一步：偏向锁检测"><a href="#第一步：偏向锁检测" class="headerlink" title="第一步：偏向锁检测"></a>第一步：偏向锁检测</h4><ol>
<li>线程检查<strong>Mark Word</strong>中是否<strong>存放了自己的 Thread ID</strong>：<ol>
<li><strong>是：</strong> 说明当前线程已经获得锁，直接进入<strong>临界区</strong>，继续执行。</li>
<li><strong>否：</strong> 表示锁处于<strong>偏向状态</strong>，但<strong>其他线程</strong>尝试获取锁，<strong>需要升级</strong>。</li>
</ol>
</li>
</ol>
<h4 id="第二步：偏向锁升级为轻量级锁"><a href="#第二步：偏向锁升级为轻量级锁" class="headerlink" title="第二步：偏向锁升级为轻量级锁"></a>第二步：偏向锁升级为轻量级锁</h4><ol>
<li><strong>CAS</strong> <strong>切换操作：</strong><ol>
<li>新线程尝试使用 <strong>CAS（Compare-And-Swap）来更新 Mark Word，将其中的线程 ID</strong>替换为<strong>轻量级锁标志</strong>。</li>
</ol>
</li>
<li><strong>撤销偏向锁：</strong><ol>
<li>如果 CAS 成功，则<strong>升级成功</strong>。</li>
<li>如果 CAS 失败，说明<strong>锁已被竞争</strong>，进入下一步。</li>
</ol>
</li>
<li><strong>暂停偏向线程：</strong><ol>
<li>新线程<strong>通知之前持有锁的线程暂停</strong>，等待其将<strong>Mark Word 置为空</strong>，即<strong>撤销偏向锁状态</strong>。</li>
</ol>
</li>
</ol>
<h4 id="第三步：轻量级锁竞争"><a href="#第三步：轻量级锁竞争" class="headerlink" title="第三步：轻量级锁竞争"></a>第三步：轻量级锁竞争</h4><ol>
<li><strong>存储<strong><strong>哈希码</strong></strong>：</strong><ol>
<li>竞争线程将<strong>锁对象的</strong> <strong>HashCode</strong>复制到自己新建的锁记录空间（Lock Record）中。</li>
</ol>
</li>
<li><strong>CAS</strong> <strong>抢占锁：</strong><ol>
<li>线程通过 CAS 操作，将<strong>锁对象的 Mark Word</strong>更新为<strong>自己新建的 Lock Record 地址</strong>。</li>
<li><strong>成功：</strong> 获得轻量级锁，进入<strong>临界区</strong>。</li>
<li><strong>失败：</strong> 进入下一步自旋。</li>
</ol>
</li>
</ol>
<h4 id="第四步：自旋等待"><a href="#第四步：自旋等待" class="headerlink" title="第四步：自旋等待"></a>第四步：自旋等待</h4><ol>
<li>如果在轻量级锁竞争中<strong>CAS</strong> <strong>失败</strong>，则线程<strong>进入****自旋</strong>：<ol>
<li><strong>自旋****等待：</strong> 线程反复检查锁是否已被释放。</li>
<li><strong>自旋****成功：</strong> 继续执行，仍为<strong>轻量级锁状态</strong>。</li>
<li><strong>自旋****失败：</strong> 次数超过阈值，进入重量级锁状态。</li>
</ol>
</li>
</ol>
<h4 id="第五步：升级为重量级锁"><a href="#第五步：升级为重量级锁" class="headerlink" title="第五步：升级为重量级锁"></a>第五步：升级为重量级锁</h4><ol>
<li><strong>自旋****失败后，锁膨胀：</strong><ol>
<li>自旋线程直接升级为<strong>重量级锁</strong>（锁膨胀）。</li>
<li>通过**操作系统的互斥量（Monitor）来管理。</li>
</ol>
</li>
<li><strong>线程阻塞：</strong><ol>
<li>未获取到锁的线程<strong>进入阻塞队列</strong>，等待持有锁的线程<strong>释放锁并唤醒自己</strong>。</li>
</ol>
</li>
</ol>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。一旦多个线程发生冲突，乐观锁通常使用一种称为 <strong>CAS</strong> 的技术来保证线程执行的安全性。</p>
<p>乐观锁适用于<strong>读多写少</strong>的环境，避免频繁失败和重试影响性能。</p>
<h3 id="什么是-CAS"><a href="#什么是-CAS" class="headerlink" title="什么是 CAS"></a>什么是 CAS</h3><p>CAS 全程是 Compare-And-Swap ,比较并交换</p>
<p><strong>核心思想：</strong></p>
<p>通过<strong>比较</strong>内存中的值和期望值，如果相同，就<strong>更新</strong>为新值；如果不同，就<strong>不做操作</strong>，继续尝试。</p>
<p>CAS 操作一般设计三个值：</p>
<ul>
<li>V：要更新的变量值(Var)</li>
<li>E：预期值(Expected)，表示线程 A <strong>希望<strong><strong>当前</strong></strong>值是什么</strong></li>
<li>N：拟写入的新值(New)</li>
</ul>
<p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</p>
<p><strong>CAS****操作本质：</strong> 确保在更新前，值是<strong>期望的老值</strong>，防止其他线程抢先更新。</p>
<p>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p>
<h4 id="CAS的原理"><a href="#CAS的原理" class="headerlink" title="CAS的原理"></a>CAS的原理</h4><p>CAS 通过操作 Unsafe 类调用底层指令，Unsafe 魔法类 位于<code>sun.misc</code>包中，它里面都是<code>native</code>方法，通过调用底层CPU指令，实现<strong>无锁操作。</strong></p>
<p>所以CAS的原子性依赖于CPU级别的指令支持，而非Java本身。</p>
<h4 id="CAS的三大问题"><a href="#CAS的三大问题" class="headerlink" title="CAS的三大问题"></a>CAS的三大问题</h4><h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>就是一个值原来是 A，变成了 B，又变回了 A。这个时候使用 CAS 是检查不出变化的，但实际上却被更新了两次。</p>
<p>ABA 问题的解决思路是在变量前面追加上版本号或者时间戳</p>
<h5 id="长时间自旋"><a href="#长时间自旋" class="headerlink" title="长时间自旋"></a>长时间自旋</h5><p>CAS 多与自旋结合。如果自旋 CAS 长时间不成功，会占用大量的 CPU 资源。</p>
<p>解决思路是让 JVM 支持处理器提供的pause 指令。</p>
<p>pause 指令能让自旋失败时 cpu 睡眠一小段时间再继续自旋，从而使得读操作的频率降低很多，为解决内存顺序冲突而导致的 CPU 流水线重排的代价也会小很多。</p>
<h5 id="多个共享变量的原子操作"><a href="#多个共享变量的原子操作" class="headerlink" title="多个共享变量的原子操作"></a>多个共享变量的原子操作</h5><p>当对一个共享变量执行操作时，CAS 能够保证该变量的原子性。但是对于多个共享变量，CAS 就无法保证操作的原子性。</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="ReentrantLock是什么"><a href="#ReentrantLock是什么" class="headerlink" title="ReentrantLock是什么"></a>ReentrantLock是什么</h3><p>ReentrantLock 实现了 Lock接口，是一个可重入且独占的锁，和 synchronized 关键字类似。但是 ReentrantLock 更加灵活强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/java/JUC/3.jpg" alt="3"></p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS 全称为 <strong>AbstractQueuedSynchronizer</strong>，是 Java 中用于构建同步器的一个<strong>抽象类</strong>，位于 <code>java.util.concurrent.locks</code> 包中。它是构建锁和其他同步组件（如 ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier 等）的核心基础。</p>
<p>它主要通过维护一个<strong>State值</strong>和一个<strong>FIFO等待队列</strong>来管理线程竞争：线程竞争失败时，被加入<strong>等待队列</strong>中；</p>
<p>通过<strong>自旋****、挂起、唤醒</strong>机制来协调线程的获取和释放。它通过CAS实现了原子性</p>
<h3 id="AQS的原理"><a href="#AQS的原理" class="headerlink" title="AQS的原理"></a>AQS的原理</h3><p>AQS的核心思想是，如果被请求的共享资源空闲，则将当前请求的线程设置为<strong>有效的工作线程</strong>，并且将共享资源设置为<strong>锁定状态</strong>。如果被请求的共享资源被占用，那么就需要一套<strong>线程阻塞等待以及被唤醒时锁分配的机制</strong>，这个机制 AQS 是基于 <strong>CLH 锁</strong> （Craig, Landin, and Hagersten locks） 进一步优化实现的。</p>
<p><strong>CLH 锁</strong> 对自旋锁进行了改进，是基于单链表的自旋锁。在多线程场景下，<strong>会将请求获取锁的线程组织成一个单向队列</strong>，每个等待的线程会通过自旋访问前一个线程节点的状态，前一个节点释放锁之后，当前节点才可以获取锁。</p>
<p>AQS 中使用的 等待队列 是 CLH 锁队列的变体（接下来简称为 CLH 变体队列）。</p>
<p>AQS 的 CLH 变体队列是一个双向队列，会暂时获取不到锁的线程将被加入到该队列中，CLH 变体队列和原本的 CLH 锁队列的区别主要有两点：</p>
<ul>
<li>由 <strong>自旋</strong> 优化为 <strong>自旋 + 阻塞</strong> ：自旋操作的性能很高，但大量的自旋操作比较占用 CPU 资源，因此在 CLH 变体队列中会先通过自旋尝试获取锁，如果失败再进行阻塞等待。</li>
<li>由 <strong>单向队列</strong> 优化为 <strong>双向队列</strong> ：在 CLH 变体队列中，会对等待的线程进行阻塞操作，当队列前边的线程释放锁之后，需要对后边的线程进行唤醒，因此增加了 <code>next</code> 指针，成为了双向队列</li>
</ul>
<p>AQS 将每条请求共享资源的线程封装成一个 CLH 变体队列的一个结点（Node）来实现锁的分配。在 CLH 变体队列中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p>
<p>AQS 中的 CLH 变体队列结构如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/java/JUC/4.jpg" alt="4"></p>
<p>AQS 使用 <strong>int</strong> <strong>成员变量</strong> <strong><code>state</code></strong> 表示同步状态，通过内置的 线程等待队列 来完成获取资源线程的排队工作。</p>
<p><code>state</code> 变量由 <code>volatile</code> 修饰，用于展示当前临界资源的获锁情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享变量，使用volatile修饰保证线程可见性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure>

<p>另外，状态信息 <code>state</code> 可以通过 <code>protected</code> 类型的<code>getState()</code>、<code>setState()</code>和<code>compareAndSetState()</code> 进行操作。并且，这几个方法都是 <code>final</code> 修饰的，在子类中无法被重写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;     <span class="keyword">return</span> state;&#125; <span class="comment">// 设置同步状态的值protected final void setState(int newState) &#123;     state = newState;&#125;//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）protected final boolean compareAndSetState(int expect, int update) &#123;      return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125;</span></span><br></pre></td></tr></table></figure>

<p>以 <code>ReentrantLock</code> 为例，<code>state</code> 初始值为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code> 独占该锁并将 <code>state+1</code> 。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 <code>unlock()</code> 到 <code>state=</code>0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（<code>state</code> 会累加），这就是<strong>可重入</strong>的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p>
<h2 id="ReentrantLock-1"><a href="#ReentrantLock-1" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p><code>ReentrantLock</code>实现了Lock接口，是一个可重入且独占的锁，和synchronized 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p>
<p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/java/JUC/5.jpg" alt="5"></p>
<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p><strong>公平锁</strong> : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</p>
<p><strong>非公平锁</strong>：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><strong><code>ThreadLocal</code></strong> 是一种用于提供线程本地变量的机制，它为每个线程提供独立的变量副本，避免了线程之间的数据共享和冲突。</p>
<h3 id="原理实现"><a href="#原理实现" class="headerlink" title="原理实现"></a>原理实现</h3><p><strong>最终的变量是放在了当前线程的</strong> <strong><code>ThreadLocalMap</code></strong> <strong>中，并不是存在</strong> <strong><code>ThreadLocal</code></strong> <strong>上，</strong><strong><code>ThreadLocal</code></strong> <strong>可以理解为只是</strong>**<code>ThreadLocalMap</code>**<strong>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p>
<p>每个<code>Thread</code>类中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</p>
<p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类。</p>
<h3 id="ThreadLocal-内存泄露问题是怎么导致的"><a href="#ThreadLocal-内存泄露问题是怎么导致的" class="headerlink" title="ThreadLocal 内存泄露问题是怎么导致的"></a>ThreadLocal 内存泄露问题是怎么导致的</h3><p>**<code>ThreadLocalMap </code><strong>使用弱引用来引用</strong><code>ThreadLocal</code><strong>对象，而 <strong><code>ThreadLocalMap</code></strong> 中的值仍然是强引用，这导致</strong><code>ThreadLocal</code><strong>被回收时，</strong><code>ThreadLocalMap </code>**中的值没有被清理，从而发生内存泄漏。</p>
<p><strong>解决方法</strong>：每次使用 <code>ThreadLocal</code> 后，都应该调用 <code>remove()</code> 方法显式地清除线程中的数据，特别是在线程池等长期存活的线程中。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池主要是为了减少每次获取资源的消耗，提高对资源的利用率</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ul>
<h3 id="如何实现线程池"><a href="#如何实现线程池" class="headerlink" title="如何实现线程池"></a>如何实现线程池</h3><ol>
<li>通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）</li>
<li>通过 Executor 框架的工具类 Executor 来创建。</li>
</ol>
<h3 id="Executor介绍"><a href="#Executor介绍" class="headerlink" title="Executor介绍"></a>Executor介绍</h3><p><code>Executor</code> 框架是 Java5 之后引进的，在 Java 5 之后，通过 <code>Executor</code> 来启动线程比使用 <code>Thread</code> 的 <code>start</code> 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。</p>
<blockquote>
<p>this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p>
</blockquote>
<p><code>Executor</code> 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，<code>Executor</code> 框架让并发编程变得更加简单。</p>
<p><code>Executor</code> 框架结构主要由三大部分组成：</p>
<p><strong>1、任务(****<code>Runnable</code></strong> <strong>&#x2F;<strong><strong><code>Callable</code></strong></strong>)</strong></p>
<p>执行任务需要实现的 <strong><code>Runnable</code></strong> <strong>接口</strong> 或 <strong><code>Callable</code>*<em><strong>接口</strong>。</em>*<code>Runnable</code></strong> <strong>接口</strong>或 <strong><code>Callable</code></strong> <strong>接口</strong> 实现类都可以被 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。</p>
<p><strong>2、任务的执行(<strong><strong><code>Executor</code></strong></strong>)</strong></p>
<p>如下图所示，包括任务执行机制的核心接口 <strong><code>Executor</code></strong> ，以及继承自 <code>Executor</code> 接口的 <strong><code>ExecutorService</code></strong> <strong>接口。</strong><strong><code>ThreadPoolExecutor</code></strong> 和 <strong><code>ScheduledThreadPoolExecutor</code></strong> 这两个关键类实现了 <strong><code>ExecutorService</code></strong> 接口。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/java/JUC/6.jpg" alt="6"></p>
<p><strong>3、异步计算的结果(<strong><strong><code>Future</code></strong></strong>)</strong></p>
<p><strong><code>Future</code></strong> 接口以及 <code>Future</code> 接口的实现类 <strong><code>FutureTask</code></strong> 类都可以代表异步计算的结果。</p>
<p>当我们把 **<code>Runnable</code>**<strong>接口</strong> 或 <strong><code>Callable</code></strong> <strong>接口</strong> 的实现类提交给 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。</p>
<p>通过<code>Executors</code>工具类可以创建多种类型的线程池，包括：</p>
<p><code>FixedThreadPool</code>：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p>
<p><code>SingleThreadExecutor</code>： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</p>
<p><code>CachedThreadPool</code>： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</p>
<p><code>ScheduledThreadPool</code>：给定的延迟后运行任务或者定期执行任务的线程池。</p>
<h3 id="ThreadPoolExcutor-类介绍"><a href="#ThreadPoolExcutor-类介绍" class="headerlink" title="ThreadPoolExcutor 类介绍"></a>ThreadPoolExcutor 类介绍</h3><p><code>ThreadPoolExecutor</code> 类中有的四个构造方法，以下是最长的，其他的三个构造方法也是在其的基础上产生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//线程池的核心线程数量</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,//线程池的最大线程数</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">                          TimeUnit unit,//时间单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">                           )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ThreadPoolExecutor</code> 3 个最重要的参数：</p>
<ul>
<li><code>corePoolSize</code> : 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li>
<li><code>maximumPoolSize</code> : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><code>workQueue</code>: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/java/JUC/7.jpg" alt="7"></p>
<p><strong><code>ThreadPoolExecutor</code></strong> <strong>拒绝策略定义:</strong></p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolExecutor</code> 定义一些策略:</p>
<ul>
<li><code>ThreadPoolExecutor.AbortPolicy</code>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<h3 id="线程池常用的阻塞队列总结"><a href="#线程池常用的阻塞队列总结" class="headerlink" title="线程池常用的阻塞队列总结"></a>线程池常用的阻塞队列总结</h3><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p>
<p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p>
<ul>
<li>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）：<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code> 。<code>FixedThreadPool</code>最多只能创建核心线程数的线程（核心线程数和最大线程数相等），<code>SingleThreadExector</code>只能创建一个线程（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。</li>
<li><code>SynchronousQueue</code>（同步队列）：<code>CachedThreadPool</code> 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li>
<li><code>DelayedWorkQueue</code>（延迟阻塞队列）：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1&#x2F;2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li>
</ul>
<p><code>Executors</code> 返回线程池对象的弊端如下：</p>
<ul>
<li><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>:使用的是阻塞队列 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>，可以看作是无界的，可能堆积大量的请求，从而导致 OOM。</li>
<li><code>CachedThreadPool</code>:使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。</li>
<li><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code>:使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
</ul>
<p>所以在阿里巴巴的Java开发手册中明确禁止了使用<code>Executors</code>, 而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式。</p>
<h2 id="锁总结"><a href="#锁总结" class="headerlink" title="锁总结"></a>锁总结</h2><p>java的锁其实就是可以说是围绕性能和安全性而展开的：</p>
<ul>
<li>待总结</li>
</ul>
<p>&#x2F;&#x2F;todo</p>
<h2 id="面试题补充"><a href="#面试题补充" class="headerlink" title="面试题补充"></a>面试题补充</h2><h3 id="Synchronized-和-ReentrantLock-有什么区别？"><a href="#Synchronized-和-ReentrantLock-有什么区别？" class="headerlink" title="Synchronized 和 ReentrantLock 有什么区别？"></a>Synchronized 和 ReentrantLock 有什么区别？</h3><p>两者都是可重入锁：指的是线程可以再次获取自己的内部锁</p>
<p>JDK 提供的所有现成的 <code>Lock</code> 实现类，包括 <code>synchronized</code> 关键字锁都是可重入的。</p>
<p>当一个类中有两个方法都使用了synchronized 关键字，并且方法二调用了方法一，由于synchronized 锁是可重入的，同一个线程在调用方法二时可以直接获得当前对象的锁，执行方法一的时候再次获得这个对象的锁，不会产生死锁问题。</p>
<p><strong>Svnchronized 依赖于</strong> <strong>JVM</strong> <strong>而 ReentrantLock 依赖于<strong><strong>API</strong></strong>：</strong></p>
<p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，我们看不到</p>
<p><code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成</p>
<p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有四点：</p>
<ul>
<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说当前线程在等待获取锁的过程中，如果其他线程中断当前线程「 <code>interrupt()</code> 」，当前线程就会抛出 <code>InterruptedException</code> 异常，可以捕捉该异常进行相应处理。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li>
<li><strong>支持超时</strong> ：<code>ReentrantLock</code> 提供了 <code>tryLock(timeout)</code> 的方法，可以指定等待获取锁的最长等待时间，如果超过了等待时间，就会获取锁失败，不会一直等待。</li>
</ul>
<h3 id="什么是线程同步？"><a href="#什么是线程同步？" class="headerlink" title="什么是线程同步？"></a>什么是线程同步？</h3><p>线程同步是指在多线程环境下，为了避免多个线程对共享资源进行同时访问，从而引发数据不一致或者其他问题的一个机制。它通过对关键代码进行加锁，使得同一时刻只有一个线程能够访问共享资源。</p>
<h1 id="JUC重新理解整理"><a href="#JUC重新理解整理" class="headerlink" title="JUC重新理解整理"></a>JUC重新理解整理</h1><p>在这里我将对JUC的知识重新做一个系统性的整理</p>
<h2 id="Java并发理论基础：Java内存模型（JMM）与线程"><a href="#Java并发理论基础：Java内存模型（JMM）与线程" class="headerlink" title="Java并发理论基础：Java内存模型（JMM）与线程"></a>Java并发理论基础：Java内存模型（JMM）与线程</h2><h3 id="为什么需要多线程？"><a href="#为什么需要多线程？" class="headerlink" title="为什么需要多线程？"></a>为什么需要多线程？</h3><p>从计算机系统“<strong>性能失衡</strong>”这个核心问题出发，众所周知，CPU、缓存、I&#x2F;O设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献</p>
<p>1️⃣ <strong>CPU</strong> <strong>增加缓存 → 导致可见性问题</strong></p>
<ul>
<li>✔️ 你说得对：<strong>CPU</strong> <strong>缓存（如 L1&#x2F;L2&#x2F;L3）确实是为了加速<strong><strong>内存</strong></strong>访问，减少延迟</strong>；</li>
<li>⚠️ 问题产生：当多个线程在多个核心上运行，每个核心使用自己的 CPU 缓存时，<strong>对共享变量的修改不会立刻对其他线程可见</strong>；<ul>
<li>这就是并发编程中的<strong>可见性问题</strong>；</li>
</ul>
</li>
<li>💡 Java 提供了 <code>volatile</code>、synchronized、内存屏障等机制来缓解这个问题。</li>
</ul>
<p>2️⃣ <strong>操作系统****引入进程&#x2F;线程 → 导致原子性问题</strong></p>
<ul>
<li>✔️ 进程&#x2F;线程的引入确实是为了更高效利用 CPU、提高并发性；</li>
<li>⚠️ 问题产生：<strong>多个线程并发执行共享资源时，如果没有合适的同步机制，就可能在同一时间访问或修改同一个变量，导致中间状态被破坏</strong>；<ul>
<li>举例：两个线程同时对一个变量做 <code>i++</code>，就可能丢失更新；</li>
</ul>
</li>
<li>💡 这就是原子性问题，需要通过 <code>synchronized</code>、<code>Lock</code>、原子类（如 <code>AtomicInteger</code>）等机制保证。</li>
</ul>
<p>3️⃣ <strong>编译器重排序优化 → 导致有序性问题</strong></p>
<ul>
<li>✔️ 为了提高执行效率，<strong>编译器和</strong> <strong>CPU</strong> <strong>都可能对<strong><strong>指令</strong></strong>进行重排序</strong>，前提是<strong>单线程下语义等价</strong>；</li>
<li>⚠️ 在多线程环境下，重排序可能会导致“<strong>指令****执行顺序和代码书写顺序不一致</strong>”，从而出现一些<strong>难以察觉的并发 bug</strong>；<ul>
<li>举例：双重检查锁（DCL）中如果不加 <code>volatile</code>，可能会读取到未初始化的对象；</li>
</ul>
</li>
<li>💡 这就是有序性问题，Java 的内存模型（JMM）和 <code>volatile</code> 能提供一定程度的顺序保证。</li>
</ul>
<p>总结：</p>
<table>
<thead>
<tr>
<th>系统组件</th>
<th>优化手段</th>
<th>性能优化目标</th>
<th>引发的问题（并发角度）</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td>缓存机制</td>
<td>提升内存访问效率</td>
<td>可见性问题</td>
</tr>
<tr>
<td>OS</td>
<td>线程&#x2F;进程</td>
<td>利用 CPU 与 I&#x2F;O 并行</td>
<td>原子性问题</td>
</tr>
<tr>
<td>编译器&#x2F;CPU</td>
<td>指令重排</td>
<td>提高执行效率</td>
<td>有序性问题</td>
</tr>
</tbody></table>
<h3 id="JAVA是怎么解决并发问题的-JMM-Java内存模型"><a href="#JAVA是怎么解决并发问题的-JMM-Java内存模型" class="headerlink" title="JAVA是怎么解决并发问题的: JMM(Java内存模型)"></a>JAVA是怎么解决并发问题的: JMM(Java内存模型)</h3><p><strong>理解的第一个维度：核心知识点</strong></p>
<p>JMM本质上可以理解为，<strong>Java</strong> <strong>内存****模型规范了</strong> <strong>JVM</strong> <strong>如何提供按需禁用缓存和编译优化的方法</strong>。具体来说，这些方法包括：</p>
<ul>
<li><p>volatile、synchronized 和 final 三个关键字(具体在之后讲述)</p>
</li>
<li><p>Happens-Before 规则:</p>
<ul>
<li><p>Happens-Before 是 Java 内存模型（JMM）中定义的一个关键规则，用于规定多线程环境下操作之间的执行顺序，从而解决可见性和有序性问题。它包含 8 条基本规则，JVM 在实际运行时会遵循这些规则来保证线程间的正确通信与同步。</p>
</li>
<li><table>
<thead>
<tr>
<th></th>
<th>规则</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>程序次序规则</td>
<td>同一个线程中，程序代码按顺序执行（单线程内天然有序）</td>
</tr>
<tr>
<td>2</td>
<td>监视器锁规则</td>
<td>一个 unlock 操作 happens-before 于后续的 lock 同一把锁</td>
</tr>
<tr>
<td>3</td>
<td>volatile 变量规则</td>
<td>对一个 volatile 变量的写操作 happens-before 于后续对它的读</td>
</tr>
<tr>
<td>4</td>
<td>线程启动规则</td>
<td>Thread.start() 先于新线程中的任何操作</td>
</tr>
<tr>
<td>5</td>
<td>线程终止规则</td>
<td>线程中所有操作都 happens-before 于其他线程检测到它终止（如 join() 返回）</td>
</tr>
<tr>
<td>6</td>
<td>线程中断规则</td>
<td>调用 interrupt() 先于被中断线程检测中断</td>
</tr>
<tr>
<td>7</td>
<td>对象构造规则</td>
<td>构造函数中所有操作 happens-before 于对象引用被其他线程访问</td>
</tr>
<tr>
<td>8</td>
<td>传递性规则</td>
<td>如果 A happens-before B，B happens-before C ⇒ A happens-before C</td>
</tr>
</tbody></table>
</li>
<li></li>
</ul>
</li>
</ul>
<p><strong>理解的第二个维度：可见性，有序性，原子性</strong></p>
<ul>
<li>原子性</li>
</ul>
<p><strong>Java内存模型****只保证了基本读取和赋值是原子性操作</strong>，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。<strong>由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</strong></p>
<ul>
<li>可见性</li>
</ul>
<p>Java提供了<strong>volatile关键字来保证可见性</strong>。</p>
<p>当一个共享变量被volatile修饰时，<strong>它会保证修改的值会立即被更新到****主存</strong>，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，通过<strong>synchronized</strong>和<strong>Lock</strong>也能够保证<strong>可见性，</strong>synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<ul>
<li>有序性</li>
</ul>
<p>在Java里面，可以通过<strong>volatile</strong>关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。</p>
<h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><h4 id="阻塞同步"><a href="#阻塞同步" class="headerlink" title="阻塞同步"></a>阻塞同步</h4><p>synchronized 和 ReentrantLock。</p>
<p>互斥同步属于一种<strong>悲观的并发策略</strong>，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、<strong>用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒</strong>等操作。</p>
<h4 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h4><ul>
<li><strong>CAS</strong></li>
</ul>
<p>CAS 本质上就是先读再比对，读出来的值和预期一样才会更新。是最底层的乐观锁机制，它的具体实现依赖于 JVM 提供的底层工具 —— 比如 <code>Unsafe</code> 或 <code>VarHandle</code>。 而 Java 提供的 <code>AtomicInteger</code>、<code>AtomicReference</code> 等原子类， 底层就是通过调用 <code>Unsafe</code> 中的 CAS 方法来实现的</p>
<p>CAS 操作本质上做的就是这三步：</p>
<ol>
<li><strong>读取<strong><strong>内存</strong></strong>地址</strong> <strong><code>V</code></strong> <strong>的当前值</strong>（这一步就是你说的“先查询”）；</li>
<li>将当前值与期望值 <code>A</code> 进行比较；</li>
<li>如果一致，则将其更新为新值 <code>B</code>；</li>
<li>如果不一致，则<strong>不做修改</strong>，通常返回失败信号（如 <code>false</code> 或当前值），你需要自行重试。</li>
</ol>
<p>这整个操作在硬件层面是一个<strong>原子操作</strong>（不可中断）。</p>
<ul>
<li><strong>AtomicXXX(原子类)</strong></li>
</ul>
<p>高层封装，底层调用 CAS 操作，线程安全，用户友好</p>
<p>底层就是调用 CAS（通过 Unsafe 或 VarHandle 实现）</p>
<h4 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h4><p>要保证线程安全，并不是一定就要进行同步。如果一个方法<strong>本来就不涉及共享数据</strong>，那它自然就无须任何同步措施去保证正确性</p>
<ul>
<li><strong>栈封闭</strong></li>
</ul>
<p>多个线程访问同一个<strong>方法的****局部变量</strong>时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p>
<ul>
<li><strong>线程本地存储</strong><strong>(<strong><strong>Thread Local Storage</strong></strong>)</strong></li>
</ul>
<p><code>ThreadLocal</code> 是 Java 提供的一个<strong>线程本地变量工具类</strong>，它让每个线程<strong>拥有自己的专属变量副本</strong>，彼此互不干扰。</p>
<p>底层实现：每个线程（Thread 类）内部维护了一个 <code>ThreadLocalMap</code>，它的 key 是 <code>ThreadLocal</code> 实例，value 是你存进去的变量值。</p>
<p>注意事项：一定要用<code>remove()</code>方法清理数据，线程池中的线程是复用的，如果不清除数据，旧线程可能会残留之前请求的变量，导致脏数据或内存泄露</p>
<ul>
<li>可重入代码</li>
</ul>
<p>指<strong>在<strong><strong>多线程</strong></strong>或<strong><strong>递归</strong></strong>环境下可以安全被多次调用的代码</strong>，即：</p>
<blockquote>
<p><strong>即使当前方法尚未执行完毕，被另一个线程或同一个线程再次调用，也不会出错。</strong></p>
</blockquote>
<h2 id="Java并发-线程基础"><a href="#Java并发-线程基础" class="headerlink" title="Java并发-线程基础"></a>Java并发-线程基础</h2><h3 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h3><p>Java线程的六种状态(Thread.State枚举类)</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>新建状态，线程对象已创建，但尚未启动。</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>可运行状态，线程已调用 start() 方法，等待 CPU 调度。</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态，线程等待获取某个锁（synchronized）。</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态，无限期等待其他线程的显式唤醒（如 wait()）。</td>
</tr>
<tr>
<td>TIMED_WAITING</td>
<td>有限等待状态，等待一定时间（如 sleep()、join() 带超时）。</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，线程执行完毕或抛出异常。</td>
</tr>
</tbody></table>
<h3 id="线程使用方式"><a href="#线程使用方式" class="headerlink" title="线程使用方式"></a>线程使用方式</h3><p>🧩 方式一：继承 Thread 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MyThread</span>().start(); <span class="comment">// ✅ 这里调用了 start()</span></span><br></pre></td></tr></table></figure>

<p>🧩 方式二：实现 Runnable 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start(); <span class="comment">// ✅ 还是 start()</span></span><br></pre></td></tr></table></figure>

<p>🧩 方式三：实现 Callable 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImplementsCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3......&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;zhuZi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ImplementsCallable</span> <span class="variable">callable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImplementsCallable</span>();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🧩 方式四：使用线程池（ExecutorService）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">executor.execute(() -&gt; System.out.println(<span class="string">&quot;Thread pool task&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>线程池****内部怎么实现的？</strong></p>
<blockquote>
<p>它也是用 <code>new Thread(...).start()</code> 的方式来真正启动线程的，只不过线程被复用了（线程池复用核心线程）。</p>
</blockquote>
<p>总结：</p>
<ul>
<li>①继承<code>Thread</code>类，并重写<code>run()</code>方法；</li>
<li>②实现<code>Runnable</code>接口，并传递给<code>Thread</code>构造器；</li>
<li>③实现<code>Callable</code>接口，创建有返回值的线程；</li>
<li>④使用<code>Executor</code>框架创建线程池。</li>
</ul>
<p>但是从本质上来说：</p>
<p><strong>在</strong>**<code>Java</code><strong><strong>中，创建线程的方式就只有一种：调用</strong></strong><code>Thread.start()</code>**<strong>方法</strong>！</p>
<p>因为创建线程的实质是：<strong>在<strong><strong>操作系统</strong></strong>层面正在启动一个新的线程来运行代码。</strong>无论你用了哪种高级封装，Java 中真正启动线程、执行代码，都离不开 <code>Thread.start()</code> 这一个底层调用。</p>
<p>再回头来看<code>Runnable、Callable</code>，这俩既然不是创建线程的方式，那它们具体是什么？准确来说，这是两种创建”线程体”的方式，包括继承Thread类重写 run() 方法也是。Runnable是一个顶级接口，里面只有一个方法：<code>run()</code>,代表任务逻辑，也就是想让线程去干的事情。</p>
<blockquote>
<p>为什么说更加推荐实现 Runnable 接口的方式来实现多线程?</p>
<ol>
<li>Java单继承，使用Runnbale更加灵活</li>
<li>线程任务和线程本体分离，更符合设计原则</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li>
</ol>
</blockquote>
<h3 id="基础线程机制"><a href="#基础线程机制" class="headerlink" title="基础线程机制"></a>基础线程机制</h3><ul>
<li>Executor</li>
</ul>
<p><code>Executor</code> 是 <strong>线程池****的核心接口</strong>，用于<strong>解耦****任务提交和任务执行的过程。</strong>它定义了**”执行任务”**的能力</p>
<p>常见实现类：</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ThreadPoolExecutor</td>
<td>核心实现类，线程池本体，控制线程数量、队列等。</td>
</tr>
<tr>
<td>ScheduledThreadPoolExecutor</td>
<td>支持定时或周期性任务。</td>
</tr>
<tr>
<td>ExecutorService</td>
<td>Executor 的子接口，增加了生命周期控制（如 shutdown()）。</td>
</tr>
<tr>
<td>Executors</td>
<td>工具类，用于快速创建线程池。</td>
</tr>
</tbody></table>
<ul>
<li>Daemon</li>
</ul>
<p><strong>Daemon（<strong><strong>守护线程</strong></strong>）</strong> 是一种特殊类型的线程， 是为其他线程（主要是用户线程）提供服务的后台线程。 当 <strong>所有用户线程都结束</strong> 后，<strong>JVM</strong> <strong>会自动退出</strong>，即使守护线程还在运行。</p>
<ul>
<li>sleep()</li>
</ul>
<p><code>Thread.sleep(millisec)</code> 方法会休眠<strong>当前正在执行的线程</strong>，millisec 单位为毫秒。</p>
<ul>
<li>yield(</li>
</ul>
<p>静态方法 Thread.yield() 的调用<strong>声明了当前线程已经完成了生命周期中最重要的部分</strong>，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行</p>
<h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>线程中断（interrupt）不是强制终止线程，而是将线程的 <strong>中断标志位</strong> 设置为 <code>true</code>。这个标志只是一个信号，需要线程<strong>自己在运行过程中检测</strong>，并做出响应。</p>
<p>线程中断本身不会改变线程的运行状态（如 RUNNABLE、BLOCKED 等），而是更改了线程的中断标志位。<strong>本质上只是一个布尔标志位</strong>（<code>true/false</code>）。表示：<strong>“这个线程是否被请求中断”</strong>。</p>
<p><strong>停止</strong>一个线程的方法：</p>
<ul>
<li>异常法停止：线程调用interrupt()方法之后，在<strong>线程的run方法中判断当前对象的interrupted()状态,如果是中断状态则抛出异常</strong>，达到中断线程的效果。</li>
<li>在沉睡中停止：先将线程sleep()，然后调用interrput标记中断状态，<strong>interrupt****会将阻塞状态的线程中断</strong>。会抛出中断异常，达到停止线程的效果。</li>
<li>stop()暴力停止：线程调用stop()方法会被暴力停止，方法已启用，该方法会有不好的结果：强制让线程停止可能使一些请理性的工作得不到完成。</li>
<li>使用return停止线程：调用interrupt标记为中断状态后，在<strong>run方法中判断当前线程状态，如果为中断状态则return</strong> ，能达到停止线程的效果。</li>
</ul>
<h3 id="线程互斥同步"><a href="#线程互斥同步" class="headerlink" title="线程互斥同步"></a>线程互斥同步</h3><p><strong>Java 提供了两种锁机制来控制多个线程对共享资源的<strong><strong>互斥</strong></strong>访问</strong>，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>
<h3 id="线程之间的协作"><a href="#线程之间的协作" class="headerlink" title="线程之间的协作"></a>线程之间的协作</h3><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对<strong>线程进行协调</strong>。</p>
<ul>
<li><strong>join()</strong></li>
</ul>
<p><code>join()</code> 是 <code>Thread</code> 类提供的方法，意思是：“<strong>等我执行完你再继续</strong>”。</p>
<p>它会使<strong>调用它的线程暂停执行</strong>，直到目标线程完成。</p>
<ul>
<li><strong>Object的wait()&#x2F;notify()&#x2F;notifyAll()</strong></li>
</ul>
<p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p>
<p>它们都属于 Object 的一部分，而不属于 Thread。</p>
<p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。</p>
<p><strong>使用 wait() 挂起期间，线程会释放锁</strong>。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p>
<blockquote>
<p><strong>wait() 和</strong> <strong>sleep()</strong> <strong>的区别</strong></p>
<ul>
<li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li>
<li>wait() 会释放锁，sleep() 不会。</li>
</ul>
</blockquote>
<ul>
<li>Condition的await()&#x2F;signal()&#x2F;signalAll()</li>
</ul>
<p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p>
<ul>
<li>LockSupport 的park()&#x2F;unpark()</li>
</ul>
<p><code>LockSupport</code> 是一种比 <code>synchronized</code> 和 <code>wait/notify</code> 更<strong>底层</strong>、更灵活的线程阻塞&#x2F;唤醒机制，提供了可以挂起（阻塞）和恢复线程的工具方法，<strong>是构建线程同步工具的核心类</strong>。</p>
<p><strong>注意：它们不需要在同步块中使用，不需要锁。甚至是<strong><strong>AQS</strong></strong>的基础，AQS 就使用了</strong> <strong><code>LockSupport</code></strong> <strong>来控制线程的阻塞与唤醒。</strong></p>
<p>Demo：实现线程C需要等待线程AB执行完成才能执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程c已开启，等待A,B完成才继续执行&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程c继续执行&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    c.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程A开始执行&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程A执行完成&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (flag.decrementAndGet() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//唤醒指定线程</span></span><br><span class="line">            LockSupport.unpark(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程B开始执行&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程B执行完成&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (flag.decrementAndGet() == <span class="number">0</span>)&#123;</span><br><span class="line">            LockSupport.unpark(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TimeUnit</code> 是 Java 中一个<strong>时间单位枚举类</strong>，位于 <code>java.util.concurrent.TimeUnit</code>，可以让我们<strong>以不同时间单位来表达时间延迟</strong>，更直观更清晰。</p>
<h2 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h2><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><ul>
<li>锁<strong>从乐观和悲观的角度</strong>可分为乐观锁和悲观锁<ul>
<li>乐观锁</li>
<li>悲观锁</li>
</ul>
</li>
<li>公平锁和非公平锁<ul>
<li>公平锁：指多个线程按照申请锁的顺序来获取锁<ul>
<li>在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己。</li>
</ul>
</li>
<li>非公平锁：指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后中请的线程比先中请的线程优先获取锁。<ul>
<li>非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式</li>
<li>非公平锁的优点在于吞吐量比公平锁大。</li>
</ul>
</li>
<li><strong>Lock是支持公平锁的，synchronized不支持公平锁。</strong></li>
</ul>
</li>
<li>从<strong>是否共享资源的角度</strong> 可分为共享锁和独占锁<ul>
<li><strong>独占锁</strong>：指该锁一次只能被一个线程所持有。对 ReentrantLock 和 Synchronized 而言都是独占锁。</li>
<li><strong>共享锁</strong>：指该锁可被多个线程所持有。<ul>
<li>对 <code>ReentrantReadWriteLock</code> 其<strong>读锁<strong><strong>是</strong></strong>共享锁<strong><strong>，其</strong></strong>写锁****是独占锁</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>从<strong>锁的状态的角度</strong>可分为偏向锁、轻量级锁和重量级锁。同时，<strong>在<strong><strong>JVM</strong></strong>中还巧妙设计了<strong><strong>自旋锁</strong></strong>以更快地使用<strong><strong>CPU</strong></strong>资源</strong>。<ul>
<li>偏向锁 –》轻量级锁 –》自旋锁、自适应自旋、锁消除、锁粗化。</li>
<li>自旋锁 – JVM<ul>
<li>是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</li>
<li>自旋锁认为：如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞、挂起状态，只需等一等（也叫作自旋），在等待持有锁的线程释放锁后即可立即获取锁，这样就避免了用户线程在内核状态的切换上导致的锁时间消耗。线程在自旋时会占用CPU，在线程长时间自旋获取不到锁时，将会产CPU的浪费，甚至有时线程永远无法获取锁而导致CPU资源被永久占用，所以需要设定一个自旋等待的最大时间。在线程执行的时间超过自旋等待的最大时间后，线程会退出自旋模式并释放其持有的锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="关键字Synchronized详解"><a href="#关键字Synchronized详解" class="headerlink" title="关键字Synchronized详解"></a>关键字Synchronized详解</h2><h3 id="Synchronized的使用"><a href="#Synchronized的使用" class="headerlink" title="Synchronized的使用"></a>Synchronized的使用</h3><p>在应用Synchronize时需注意：</p>
<ul>
<li>一把锁同时只能被一个线程获取，没有获得锁的线程只能等待</li>
<li>每个实例都对应自己的一把锁(this)，不同实例之间互不影响；例外：锁对象是*.class以及synchronized 写实的是static方法时，所有对象共用一把锁</li>
<li>synchronized修饰的方法，<strong>无论方法正常执行完毕还是抛出异常，都会释放锁</strong></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://lypsblog.top">实名上网陆熠鹏</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://lypsblog.top/2025/06/21/JUC%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%87%E5%AD%97%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82JUC%EF%BC%89%E6%A1%86%E6%9E%B6%E5%BB%BA%E7%AB%8B%EF%BC%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E7%90%86%E8%A7%A3/">http://lypsblog.top/2025/06/21/JUC%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%87%E5%AD%97%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82JUC%EF%BC%89%E6%A1%86%E6%9E%B6%E5%BB%BA%E7%AB%8B%EF%BC%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E7%90%86%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JUC/">JUC</a></div><div class="post_share"><div class="social-share" data-image="/img/java/java.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/06/21/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%B8%A6%E4%BD%A0%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3Mysql%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6%EF%BC%81-%E5%B8%A6%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A1%A5%E5%85%85/" title="由浅入深带你快速理解Mysql内部机制！(带面试题补充)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/mysql.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">由浅入深带你快速理解Mysql内部机制！(带面试题补充)</div></div></a></div><div class="next-post pull-right"><a href="/2025/05/08/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="JVM知识点整理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/java.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next</div><div class="next_info">JVM知识点整理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/06/17/git%E8%AF%A6%E8%A7%A3/" title="git详解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/git.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-17</div><div class="title">git详解</div></div></a></div><div><a href="/2024/06/26/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" title="Java基础学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-26</div><div class="title">Java基础学习</div></div></a></div><div><a href="/2024/06/30/Java%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/" title="Java容器用法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-30</div><div class="title">Java容器用法</div></div></a></div><div><a href="/2024/09/06/Springboot%E7%AE%80%E5%8D%95%E5%9B%9E%E9%A1%BE/" title="Springboot简单回顾"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/springboot.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-06</div><div class="title">Springboot简单回顾</div></div></a></div><div><a href="/2024/08/12/Flexbox%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90/" title="Flexbox弹性盒子"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-12</div><div class="title">Flexbox弹性盒子</div></div></a></div><div><a href="/2024/09/12/mysql%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/" title="Mysql常用方法整理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-12</div><div class="title">Mysql常用方法整理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">实名上网陆熠鹏</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lyp6666666"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lyp6666666" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:532567840@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://leetcode.cn/u/frosty-boydw85/" target="_blank" title="LeetCode"><i class="fas fa-code"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Welcome to my blog !</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JUC%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%87%E5%AD%97%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82JUC%EF%BC%89%E6%A1%86%E6%9E%B6%E5%BB%BA%E7%AB%8B%EF%BC%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E7%90%86%E8%A7%A3"><span class="toc-text">JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">创建线程的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-text">实现Runnable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread-%E7%B1%BB"><span class="toc-text">继承Thread 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.实现Callable接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">控制线程的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep"><span class="toc-text">sleep()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-text">join()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setDaemen"><span class="toc-text">setDaemen()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yield"><span class="toc-text">yield()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%9ACallable%E3%80%81Future%E5%92%8CFuture-Task"><span class="toc-text">获取Java线程的执行结果：Callable、Future和Future Task</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Callable%E6%98%AF%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84"><span class="toc-text">Callable是有返回值的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C%E7%9A%84-Future-%E6%8E%A5%E5%8F%A3"><span class="toc-text">异步计算结果的 Future 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C-FutureTask-%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">异步计算结果 FutureTask 实现类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-text">Java线程的六种状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NEW"><span class="toc-text">NEW</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RUNNABLE"><span class="toc-text">RUNNABLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BLOCKED"><span class="toc-text">BLOCKED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WAITING"><span class="toc-text">WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TIMED-WAITING"><span class="toc-text">TIMED_WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TERMINATED"><span class="toc-text">TERMINATED</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM"><span class="toc-text">Java的内存模型(JMM)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A2%E7%84%B6%E5%A0%86%E6%98%AF%E5%85%B1%E4%BA%AB%E7%9A%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E5%A0%86%E4%B8%AD%E4%BC%9A%E6%9C%89%E5%86%85%E5%AD%98%E4%B8%8D%E5%8F%AF%E8%A7%81%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">既然堆是共享的，为什么在堆中会有内存不可见问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9F"><span class="toc-text">如何保证内存可见性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM%E4%B8%8E%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-text">JMM与重排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM%E4%B8%8E-happens-before"><span class="toc-text">JMM与 happens-before</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Happens-Before-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">Happens-Before 的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">Java volatile关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%8C%E9%87%8D%E9%94%81"><span class="toc-text">volatile 可以实现单例模式的双重锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">Java synchronized 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-text">特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-text">用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%88%E9%94%81%E4%B8%BA%E5%BD%93%E5%89%8D%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-text">修饰实例方法（锁为当前实例对象）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%88%E9%94%81%E4%B8%BA%E5%BD%93%E5%89%8D%E7%B1%BB%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-text">修饰静态方法（锁为当前类对象）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">修饰代码块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">底层原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Synchronized-%E9%94%81%E7%9A%84%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text">Synchronized 锁的到底是什么，偏向锁、轻量级锁、重量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E9%94%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81%E5%8F%8A%E9%94%81%E9%99%8D%E7%BA%A7"><span class="toc-text">内置锁的四种状态及锁降级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%81%E6%94%BE%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9"><span class="toc-text">对象的锁放在什么地方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text">重量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">加锁过程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%94%81%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">解锁过程：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E5%92%8C%E9%99%8D%E7%BA%A7"><span class="toc-text">锁升级和降级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%87%E7%BA%A7%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-text">升级的具体流程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%81%8F%E5%90%91%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-text">第一步：偏向锁检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%81%8F%E5%90%91%E9%94%81%E5%8D%87%E7%BA%A7%E4%B8%BA%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text">第二步：偏向锁升级为轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%AB%9E%E4%BA%89"><span class="toc-text">第三步：轻量级锁竞争</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E8%87%AA%E6%97%8B%E7%AD%89%E5%BE%85"><span class="toc-text">第四步：自旋等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9A%E5%8D%87%E7%BA%A7%E4%B8%BA%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text">第五步：升级为重量级锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-text">乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-CAS"><span class="toc-text">什么是 CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">CAS的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98"><span class="toc-text">CAS的三大问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ABA%E9%97%AE%E9%A2%98"><span class="toc-text">ABA问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%95%BF%E6%97%B6%E9%97%B4%E8%87%AA%E6%97%8B"><span class="toc-text">长时间自旋</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-text">多个共享变量的原子操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock"><span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">ReentrantLock是什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS"><span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">AQS的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock-1"><span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text">公平锁和非公平锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0"><span class="toc-text">原理实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E6%98%AF%E6%80%8E%E4%B9%88%E5%AF%BC%E8%87%B4%E7%9A%84"><span class="toc-text">ThreadLocal 内存泄露问题是怎么导致的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">如何实现线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor%E4%BB%8B%E7%BB%8D"><span class="toc-text">Executor介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolExcutor-%E7%B1%BB%E4%BB%8B%E7%BB%8D"><span class="toc-text">ThreadPoolExcutor 类介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93"><span class="toc-text">线程池常用的阻塞队列总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E6%80%BB%E7%BB%93"><span class="toc-text">锁总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A1%A5%E5%85%85"><span class="toc-text">面试题补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized-%E5%92%8C-ReentrantLock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Synchronized 和 ReentrantLock 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="toc-text">什么是线程同步？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JUC%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3%E6%95%B4%E7%90%86"><span class="toc-text">JUC重新理解整理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text">Java并发理论基础：Java内存模型（JMM）与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">为什么需要多线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84-JMM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">JAVA是怎么解决并发问题的: JMM(Java内存模型)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">线程安全的实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5"><span class="toc-text">阻塞同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5"><span class="toc-text">非阻塞同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88"><span class="toc-text">无同步方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-text">Java并发-线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-text">线程状态转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">线程使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-text">基础线程机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"><span class="toc-text">线程中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5"><span class="toc-text">线程互斥同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C"><span class="toc-text">线程之间的协作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E9%94%81"><span class="toc-text">Java中的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">锁的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97Synchronized%E8%AF%A6%E8%A7%A3"><span class="toc-text">关键字Synchronized详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">Synchronized的使用</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/21/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%B8%A6%E4%BD%A0%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3Mysql%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6%EF%BC%81-%E5%B8%A6%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A1%A5%E5%85%85/" title="由浅入深带你快速理解Mysql内部机制！(带面试题补充)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="由浅入深带你快速理解Mysql内部机制！(带面试题补充)"/></a><div class="content"><a class="title" href="/2025/06/21/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%B8%A6%E4%BD%A0%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3Mysql%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6%EF%BC%81-%E5%B8%A6%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A1%A5%E5%85%85/" title="由浅入深带你快速理解Mysql内部机制！(带面试题补充)">由浅入深带你快速理解Mysql内部机制！(带面试题补充)</a><time datetime="2025-06-21T09:28:18.000Z" title="Created 2025-06-21 17:28:18">2025-06-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/21/JUC%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%87%E5%AD%97%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82JUC%EF%BC%89%E6%A1%86%E6%9E%B6%E5%BB%BA%E7%AB%8B%EF%BC%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E7%90%86%E8%A7%A3/" title="JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解"/></a><div class="content"><a class="title" href="/2025/06/21/JUC%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%87%E5%AD%97%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82JUC%EF%BC%89%E6%A1%86%E6%9E%B6%E5%BB%BA%E7%AB%8B%EF%BC%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E7%90%86%E8%A7%A3/" title="JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解">JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解</a><time datetime="2025-06-21T08:23:25.000Z" title="Created 2025-06-21 16:23:25">2025-06-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/08/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="JVM知识点整理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM知识点整理"/></a><div class="content"><a class="title" href="/2025/05/08/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="JVM知识点整理">JVM知识点整理</a><time datetime="2025-05-08T12:35:10.000Z" title="Created 2025-05-08 20:35:10">2025-05-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/24/HashMap%E6%80%BB%E7%BB%93/" title="HashMap总结"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HashMap总结"/></a><div class="content"><a class="title" href="/2025/04/24/HashMap%E6%80%BB%E7%BB%93/" title="HashMap总结">HashMap总结</a><time datetime="2025-04-24T15:14:13.000Z" title="Created 2025-04-24 23:14:13">2025-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/%E7%BD%91%E7%BB%9C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2025/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2025-03-31T06:49:57.000Z" title="Created 2025-03-31 14:49:57">2025-03-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 实名上网陆熠鹏</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional Chinese And Simplified Chinese">简</button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>