<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础学习 | lypのblog</title><meta name="author" content="实名上网陆熠鹏"><meta name="copyright" content="实名上网陆熠鹏"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="这个博客是我整理的 Java 基础知识的学习笔记(并不是我原创的，我也没实力原创，仅供自己和大家学习)，内容包括：Java 数据类型、Java 关键字、Java的三大特性、Java 中的 String、StringBuffer 和 StringBuilder、Java 反射、Java 异常、Java IO 流、Java 注解、Java 泛型、Java 枚举、Java 8 新特性、Java 常见的集">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础学习">
<meta property="og:url" content="http://lypsblog.top/2024/06/26/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="lypのblog">
<meta property="og:description" content="这个博客是我整理的 Java 基础知识的学习笔记(并不是我原创的，我也没实力原创，仅供自己和大家学习)，内容包括：Java 数据类型、Java 关键字、Java的三大特性、Java 中的 String、StringBuffer 和 StringBuilder、Java 反射、Java 异常、Java IO 流、Java 注解、Java 泛型、Java 枚举、Java 8 新特性、Java 常见的集">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://lypsblog.top/img/java/java.png">
<meta property="article:published_time" content="2024-06-26T09:14:09.000Z">
<meta property="article:modified_time" content="2024-06-26T13:03:13.821Z">
<meta property="article:author" content="实名上网陆熠鹏">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lypsblog.top/img/java/java.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://lypsblog.top/2024/06/26/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-26 21:03:13'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Learning notes</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/machine-learning/"><span> Machine-learning</span></a></li><li><a class="site-page child" href="/java/"><span> Java</span></a></li><li><a class="site-page child" href="/springboot/"><span> Springboot</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/java/java.png')"><nav id="nav"><span id="blog-info"><a href="/" title="lypのblog"><span class="site-name">lypのblog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Learning notes</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/machine-learning/"><span> Machine-learning</span></a></li><li><a class="site-page child" href="/java/"><span> Java</span></a></li><li><a class="site-page child" href="/springboot/"><span> Springboot</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-06-26T09:14:09.000Z" title="Created 2024-06-26 17:14:09">2024-06-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-06-26T13:03:13.821Z" title="Updated 2024-06-26 21:03:13">2024-06-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>这个博客是我整理的 Java 基础知识的学习笔记(并不是我原创的，我也没实力原创，仅供自己和大家学习)，内容包括：Java 数据类型、Java 关键字、Java的三大特性、Java 中的 String、StringBuffer 和 StringBuilder、Java 反射、Java 异常、Java IO 流、Java 注解、Java 泛型、Java 枚举、Java 8 新特性、Java 常见的集合框架源码解析。</p>
<h1 id="1-Java-数据类型详解"><a href="#1-Java-数据类型详解" class="headerlink" title="1. Java 数据类型详解"></a>1. Java 数据类型详解</h1><p>Java 数据类型有很多，本文主要从基本类型、包装类型、引用类型和缓存池四个方面来总结。</p>
<h2 id="1-1-基本数据类型"><a href="#1-1-基本数据类型" class="headerlink" title="1.1 基本数据类型"></a>1.1 基本数据类型</h2><p>基本数据类型有 byte、short、int、long、float、double、boolean、char，关于它们的分类，我画了个图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/java/1.jpg" alt="1"></p>
<p>接下来我主要从字节数、数据范围、默认值、以及用途等方面给大家总结成一个表格，一目了然。</p>
<table><thead><tr><th>数据类 型</th><th>字节数</th><th>位 数</th><th>最小值</th><th>最大值</th><th>默认 值</th><th>用途</th></tr></thead><tr><td>byte</td><td>1</td><td>8</td><td>-128</td><td>127</td><td>0</td><td>byte 类型用在大型数组中节约空 间，主要代替整数。因为 byte 变 量占用的空间只有 int 类型的四分 之一</td></tr><tr><td>short</td><td>2</td><td>16</td><td>-32768</td><td>32767</td><td>0</td><td>Short 数据类型也可以像 byte 那 样节省空间。一个short变量是int 型变量所占空间的二分之一</td></tr><tr><td>int</td><td>4</td><td>32</td><td>-2^31</td><td>2^31 - 1</td><td>0</td><td>一般地整型变量默认为 int 类型</td></tr><tr><td>long</td><td>8</td><td>64</td><td>-2^63</td><td>2^63-1</td><td>OL</td><td>这种类型主要使用在需要比较大 整数的系统上</td></tr><tr><td>float</td><td>4</td><td>32</td><td>1.4e-45</td><td>3.4e38</td><td>0.0F</td><td>float 在储存大型浮点数组的时候 可节省内存空间。浮点数不能用 来表示精确的值，如货币</td></tr></table>



<table><thead><tr><th>数据类 型</th><th>字节数</th><th>位数</th><th>最小值</th><th>最大值</th><th>默认 值</th><th>用途</th></tr></thead><tr><td>double</td><td>8</td><td>64</td><td>4.9e- 324</td><td>1.8e308</td><td>0.0D</td><td>浮点数的默认类型为double类 型。double类型同样不能表示精 确的值，如货币</td></tr><tr><td>boolean</td><td>\( \times \)</td><td>\( \times \)</td><td>\( \times \)</td><td>\( \times \)</td><td>false</td><td>true和false</td></tr><tr><td>char</td><td>2</td><td>16</td><td>\\u0000</td><td>\\uffff</td><td></td><td>char 数据类型可以储存任何字符</td></tr></table>

<h2 id="1-2-包装数据类型"><a href="#1-2-包装数据类型" class="headerlink" title="1.2 包装数据类型"></a>1.2 包装数据类型</h2><p>上面提到的基本类型都有对应的包装类型，为了方便读者查看，我也整了一个表格。</p>
<table><thead><tr><th>基本类型</th><th>包装类型</th><th>最小值</th><th>最大值</th></tr></thead><tr><td>byte</td><td>Byte</td><td>Byte.MIN_VALUE</td><td>Byte.MAX_VALUE</td></tr><tr><td>short</td><td>Short</td><td>Short.MIN_VALUE</td><td>Short.MAX_VALUE</td></tr><tr><td>int</td><td>Integer</td><td>Integer.MIN_VALUE</td><td>Integer.MAX_VALUE</td></tr><tr><td>long</td><td>Long</td><td>Long.MIN_VALUE</td><td>Long.MAX_VALUE</td></tr><tr><td>float</td><td>Float</td><td>Float.MIN_VALUE</td><td>Float.MAX_VALUE</td></tr><tr><td>double</td><td>Double</td><td>Double.MIN_VALUE</td><td>Double.MAX_VALUE</td></tr><tr><td>boolean</td><td>Boolean</td><td>Boolean.MIN_VALUE</td><td>Boolean.MAX_VALUE</td></tr><tr><td>char</td><td>Char</td><td>CHAR.MIN_VALUE</td><td>Char.MAX_VALUE</td></tr></table>

<h2 id="1-3-引用类型"><a href="#1-3-引用类型" class="headerlink" title="1.3 引用类型"></a>1.3 引用类型</h2><p>在Java中，引用类型的变量非常类似于 C&#x2F;C++ 的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Student、Dog 等。变量一旦声明后，类型就不能被改变了。</p>
<p>对象、数组都是引用数据类型。所有引用类型的默认值都是null。一个引用变量可以用来引用任何与之兼容的类型。例如:</p>
<p>Dog dog &#x3D; new Dog(“旺财”)。</p>
<h2 id="1-4-数据类型转换"><a href="#1-4-数据类型转换" class="headerlink" title="1.4 数据类型转换"></a>1.4 数据类型转换</h2><p>包装类型和基本类型之间如何转化呢?</p>
<table><tr><td>Integer \( x = 2 \) ;</td><td>// 装箱 调用了 Integer.valueOf(2)</td></tr><tr><td>int \( y = x \) ;</td><td>// 拆箱 调用了 x.intvalue()</td></tr></table>



<ol>
<li><p>把大容量的类型转换为小容量的类型时必须使用强制类型转换。</p>
</li>
<li><p>把小容量的类型转换为大容量的类型可以自动转换。</p>
</li>
</ol>
<p>比如:</p>
<p>int ( i &#x3D; {128} ) ;</p>
<p>byte ( b &#x3D; ) (byte) ( i ) ;</p>
<p>long ( c &#x3D; i ) ;</p>
<h2 id="1-5-缓存池"><a href="#1-5-缓存池" class="headerlink" title="1.5 缓存池"></a>1.5 缓存池</h2><p>大家思考一个问题: new Integer(123) 与 Integer.valueof(123) 有什么区别?</p>
<p>有些人可能知道，有些人可能不知道。其实他们的区别很大。</p>
<ol>
<li><p>new Integer(123) 每次都会新建一个对象;</p>
</li>
<li><p>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 我写个demo大家就知道了</p>
</li>
</ol>
<p>Integer ( x &#x3D; ) new Integer(123);</p>
<p>Integer ( y &#x3D; ) new Integer(123);</p>
<p>System.out.println(x &#x3D;&#x3D; y); &#x2F;&#x2F; false</p>
<p>Integer ( z &#x3D; ) Integer.valueOf ( \left( {123}\right) ) ;</p>
<p>Integer ( k &#x3D; ) Integer.valueOf(123);</p>
<p>System.out.println(z &#x3D;&#x3D; k); &#x2F;&#x2F; true</p>
<p>编译器会在自动装箱过程调用 valueof () 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。如:</p>
<hr>
<p>Integer ( m &#x3D; {123} ) ;</p>
<p>Integer ( n &#x3D; {123} ) ;</p>
<p>System.out.println(m &#x3D;&#x3D; n); &#x2F;&#x2F; true</p>
<hr>
<p>valueof() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。我们看下源码就知道。</p>
<p>public static Integer valueOf(int i) {</p>
<p>if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)</p>
<p>return IntegerCache.cache[i + (-IntegerCache.low)];</p>
<p>return new Integer(i);</p>
<p>}</p>
<p>根据数据类型的不一样，这个缓存池的上下限也不同，比如这个 Integer，就是 -128~127。不过这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax&#x3D; 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</p>
<p>参考自：StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123</p>
<p>OK，这篇文章就分享到这，Java 的数据类型虽然简单，但是里面还是有很多小细节值得我们玩味的，希望这篇文章能给大家带来一些帮助。</p>
<h1 id="2-Java-关键字详解"><a href="#2-Java-关键字详解" class="headerlink" title="2. Java 关键字详解"></a>2. Java 关键字详解</h1><p>Java 有一系列的关键字，在代码中各自有自己的重要用途与意义，今天就带着大家一起来了解一下 Java 的关键字!</p>
<p>Java 的关键字特别多，本文先主要介绍一下各个关键字的用途，然后重点介绍一下 final、static 和 this 这三个常用的关键字，其他的关键字大家用到的时候可以去网上查一下。</p>
<h2 id="2-1-Java-关键字汇总"><a href="#2-1-Java-关键字汇总" class="headerlink" title="2.1 Java 关键字汇总"></a>2.1 Java 关键字汇总</h2><table><thead><tr><th>数据类型</th><th>含义</th></tr></thead><tr><td>abstract</td><td>表明类或者成员方法具有抽象属性</td></tr><tr><td>assert</td><td>断言，用来进行程序调试</td></tr><tr><td>boolean</td><td>基本数据类型之一，布尔类型</td></tr><tr><td>break</td><td>提前跳出一个块</td></tr><tr><td>byte</td><td>基本数据类型之一，字节类型</td></tr><tr><td>case</td><td>用在switch语句之中，表示其中的一个分支</td></tr><tr><td>catch</td><td>用在异常处理中，用来捕捉异常</td></tr><tr><td>char</td><td>基本数据类型之一，字符类型</td></tr><tr><td>class</td><td>声明一个类</td></tr><tr><td>const</td><td>保留关键字，没有具体含义</td></tr><tr><td>continue</td><td>回到一个块的开始处</td></tr><tr><td>default</td><td>默认，例如，用在switch语句中，表明一个默认的分支</td></tr><tr><td>do</td><td>用在do-while循环结构中</td></tr><tr><td>double</td><td>基本数据类型之一，双精度浮点数类型</td></tr><tr><td>else</td><td>用在条件语句中，表明当条件不成立时的分支</td></tr><tr><td>enum</td><td>枚举</td></tr><tr><td>extends</td><td>表明一个类型是另一个类型的子类型，这里常见的类型有类和接口</td></tr><tr><td>final</td><td>用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或 者成员域的值不能被改变，用来定义常量</td></tr><tr><td>finally</td><td>用于处理异常情况，用来声明一个基本肯定会被执行到的语句块</td></tr><tr><td>float</td><td>基本数据类型之一，单精度浮点数类型</td></tr><tr><td>for</td><td>一种循环结构的引导词</td></tr><tr><td>goto</td><td>保留关键字，没有具体含义</td></tr><tr><td>if</td><td>条件语句的引导词</td></tr></table>



<table><thead><tr><th>数据类型</th><th>含义</th></tr></thead><tr><td>implements</td><td>表明一个类实现了给定的接口</td></tr><tr><td>import</td><td>表明要访问指定的类或包</td></tr><tr><td>instanceof</td><td>用来测试一个对象是否是指定类型的实例对象</td></tr><tr><td>int</td><td>基本数据类型之一，整数类型</td></tr><tr><td>interface</td><td>接口</td></tr><tr><td>long</td><td>基本数据类型之一，长整数类型</td></tr><tr><td>native</td><td>用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的</td></tr><tr><td>new</td><td>用来创建新实例对象</td></tr><tr><td>package</td><td>包</td></tr><tr><td>private</td><td>一种访问控制方式：私用模式</td></tr><tr><td>protected</td><td>一种访问控制方式：保护模式</td></tr><tr><td>public</td><td>一种访问控制方式：共用模式</td></tr><tr><td>return</td><td>从成员方法中返回数据</td></tr><tr><td>short</td><td>基本数据类型之一,短整数类型</td></tr><tr><td>static</td><td>表明具有静态属性</td></tr><tr><td>strictfp</td><td>用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范 [1</td></tr><tr><td>super</td><td>表明当前对象的父类型的引用或者父类型的构造方法</td></tr><tr><td>switch</td><td>分支语句结构的引导词</td></tr><tr><td>synchronized</td><td>表明一段代码需要同步执行</td></tr><tr><td>this</td><td>指向当前实例对象的引用</td></tr><tr><td>throw</td><td>抛出一个异常</td></tr><tr><td>throws</td><td>声明在当前定义的成员方法中所有需要抛出的异常</td></tr><tr><td>transient</td><td>声明不用序列化的成员域</td></tr><tr><td>try</td><td>尝试一个可能抛出异常的程序块</td></tr><tr><td>void</td><td>声明当前成员方法没有返回值</td></tr><tr><td>volatile</td><td>表明两个或者多个变量必须同步地发生变化</td></tr><tr><td>while</td><td>用在循环结构中</td></tr></table>

<p>是不是不列不知道，一列吓一跳，原来 Java 里还有这么多关键字，大部分我们平时都在用，只是没有特意去注意这个而已。所以大部分大家都很熟了，有些不常用的我也不总结了，我接下来主要总结几个比较有代表性的关键字。</p>
<h2 id="2-2-final-关键字"><a href="#2-2-final-关键字" class="headerlink" title="2.2 final 关键字"></a>2.2 final 关键字</h2><p>Java 中的 final 关键字可以用来修饰类、方法和变量 (包括实例变量和局部变量)</p>
<h2 id="2-2-1-final-修饰类"><a href="#2-2-1-final-修饰类" class="headerlink" title="2.2.1 final 修饰类"></a>2.2.1 final 修饰类</h2><p>使用final修饰类则该类不能被继承，同时类中的所有成员方法都会被隐式定义为final方法（只有在需要确保类中的所有方法都不被重写时才使用final修饰类）。final修饰类的成员变量是可以更改的</p>
<p>public final class FinalClass{</p>
<p>int ( i &#x3D; 1 ) ;</p>
<p>void test(){</p>
<p>System.out.println(“FinalClass:test”);</p>
<p>}</p>
<p>public static void main( String[] args ){</p>
<p>FinalClass ficl &#x3D; new FinalClass();</p>
<p>System.out.println(“ficl.i &#x3D; “ + ficl.i);</p>
<p>fic1.i ( &#x3D; 2 ) ;</p>
<p>System.out.println(“ficl.i &#x3D; “ + ficl.i);</p>
<p>}</p>
<p>}</p>
<h2 id="2-2-2-final-修饰方法"><a href="#2-2-2-final-修饰方法" class="headerlink" title="2.2.2 final 修饰方法"></a>2.2.2 final 修饰方法</h2><p>使用final修饰方法可以将方法“锁定”，以防止任何继承类对方法的修改，也即使用final修饰方法，则子类无法重写 (但并不影响继承和重载，即子类调用父类方法不受影响)。</p>
<h2 id="2-2-3-final-修饰变量"><a href="#2-2-3-final-修饰变量" class="headerlink" title="2.2.3 final 修饰变量"></a>2.2.3 final 修饰变量</h2><p>使用final关键字修饰变量是使用最多的情况。</p>
<p>使用final修饰变量的值不能做再次更改，即不能重新赋值。</p>
<ol>
<li><p>如果final修饰的变量是基本数据类型，则变量的值不可更改;</p>
</li>
<li><p>如果final修饰的变量是引用数据类型，则该变量不能再次指向其他引用（如重新指向新的对象或数组) 但是该变量本身的内容可以再做修改 (如数组本身的内容，或者对象的属性的修改）。</p>
</li>
</ol>
<p>无论final修饰实例变量还是局部变量，都必须在使用前显式赋初值。</p>
<ol>
<li><p>Java中的实例变量系统会对其默认赋初值，但是局部变量必须先声明后赋值再使用。</p>
</li>
<li><p>虽然对于实例变量，系统会默认赋初值，但是Java仍然规定final修饰的实例变量必须显式赋初值。实例变量显式赋值的时机可以是在声明时直接赋值，也可以先声明，后在构造方法中赋</p>
</li>
</ol>
<p>值（对于含有多个构造方法，必须在每个构造方法中都显示赋值）。</p>
<p>我们来看个例子:</p>
<p>public void fun(){</p>
<p>&#x2F;&#x2F;BufferedImage src &#x3D; null;&#x2F;&#x2F;0. 声明的同时赋值</p>
<p>BufferedImage ( \operatorname{src};&#x2F;&#x2F;1 ) . 这里不用赋初值,也不会出错</p>
<p>try{</p>
<p>src &#x3D; ImageIO.read(new File(“1.jpg”));&#x2F;&#x2F;2.</p>
<p>} catch (Exception e){</p>
<p>&#x2F;&#x2F;3. 如果出异常了就会进入这里, 那么src可能无法被赋值</p>
<p>}</p>
<p>System.out.println(src.getHeight()); &#x2F;&#x2F;4. src不一定有值, 所以无法使用 }</p>
<p>如果静态变量同时被final修饰则可以将变量视为全局变量，即在整个类加载期间，其值不变。（static保证变量属于整个类，在类加载时只对其分配一次内存；final保证变量的值不被改变)</p>
<h2 id="2-3-static-关键字"><a href="#2-3-static-关键字" class="headerlink" title="2.3 static 关键字"></a>2.3 static 关键字</h2><p>static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性， 在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法&#x2F;变量都是必须依赖具体的对象才能够被调用。</p>
<p>但是要注意的是，虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法&#x2F;变量的。也就是说，反过来是可以的。</p>
<p>如果说想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。static修饰成员方法最大的作用，就是可以使用”类名.方法名”的方式调用方法，避免了new出对象的繁琐和资源消耗。</p>
<p>我们最常见的static方法就是main方法。至于为什么main方法必须是static的，这是因为程序在执行 main方法的时候没有创建任何对象，因此只有通过类名来访问。</p>
<h2 id="2-3-1-static-变量"><a href="#2-3-1-static-变量" class="headerlink" title="2.3.1 static 变量"></a>2.3.1 static 变量</h2><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p>
<p>static成员变量的初始化顺序按照定义的顺序进行初始化。</p>
<h2 id="2-3-2-static-代码块"><a href="#2-3-2-static-代码块" class="headerlink" title="2.3.2 static 代码块"></a>2.3.2 static 代码块</h2><p>static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。</p>
<p>所谓的代码块就是当我们初始化static修饰的成员时，可以将他们统一放在一个以static开始，用花括号包裹起来的块状语句中。例如：</p>
<hr>
<p>class Person{</p>
<p>private Date birthDate;</p>
<p>public Person(Date birthDate){</p>
<p>this.birthDate ( &#x3D; ) birthDate;</p>
<p>}</p>
<p>boolean isBornBoomer(){</p>
<p>Date startDate ( &#x3D; ) Date.valueOf(“1946”);</p>
<p>Date endDate ( &#x3D; ) Date.valueOf(“1964”);</p>
<p>return birthDate.compareTo(startDate) ( &gt; &#x3D; 0&amp; ) birthDate.compareTo(endDate)</p>
<p>( &lt; 0 ) ;</p>
<p>}</p>
<p>}</p>
<hr>
<p>isBornBoomer是用来这个人是否是1946-1964年出生的，而每次isBornBoomer被调用的时候，都会生成startDate和birthDate两个对象，造成了空间浪费，如果改成这样效率会更好:</p>
<hr>
<p>class Person{</p>
<p>private Date birthDate;</p>
<p>private static Date startDate, endDate;</p>
<p>static{</p>
<p>startDate ( &#x3D; ) Date.valueOf(“1946”);</p>
<p>endDate ( &#x3D; ) Date.valueOf(“1964”);</p>
<p>}</p>
<p>public Person(Date birthDate){</p>
<p>this.birthDate ( &#x3D; ) birthDate;</p>
<p>}</p>
<p>boolean isBornBoomer(){</p>
<p>return birthDate.compareTo(startDate)&gt;&#x3D;0 &amp;&amp; birthDate.compareTo(endDate)</p>
<p>( &lt; 0 ) ;</p>
<p>}</p>
<p>}</p>
<hr>
<p>将一些只需要进行一次的初始化操作都放在static代码块中进行。</p>
<h2 id="2-4-this-关键字"><a href="#2-4-this-关键字" class="headerlink" title="2.4 this 关键字"></a>2.4 this 关键字</h2><p>this代表它所在函数所属对象的引用。简单说：哪个对象在调用this所在的函数，this就代表哪个对象。 this关键字主要有以下三个作用:</p>
<ol>
<li><p>this调用本类中的属性，也就是类中的成员变量;</p>
</li>
<li><p>this调用本类中的其他方法;</p>
</li>
<li><p>this调用本类中的其他构造方法，调用时要放在构造方法的首行。(this语句只能定义在构造函数的第一行，因为在初始化时须先执行)</p>
</li>
</ol>
<h2 id="2-4-1-引用成员变量"><a href="#2-4-1-引用成员变量" class="headerlink" title="2.4.1 引用成员变量"></a>2.4.1 引用成员变量</h2><p>public class Person{</p>
<p>String name; &#x2F;&#x2F;定义成员变量name</p>
<p>private void SetName(String name) { &#x2F;&#x2F;定义一个参数(局部变量)name</p>
<p>this. name&#x3D;name; &#x2F;&#x2F;将局部变量的值传递给成员变量</p>
<p>}</p>
<p>}</p>
<p>虽然我们可以看明白这个代码的含义，但是作为Java编译器它是怎么判断的呢?到底是将形式参数name 的值传递给成员变量name，还是反过来将成员变量name的值传递给形式参数name呢?也就是说，两个变量名字如果相同的话，那么Java如何判断使用哪个变量？此时this这个关键字就起到作用了。this这个关键字其代表的就是对象中的成员变量或者方法。也就是说，如果在某个变量前面加上一个this关键字， 其指的就是这个对象的成员变量或者方法，而不是指成员方法的形式参数或者局部变量。</p>
<h2 id="2-4-2-调用类的构造器方法"><a href="#2-4-2-调用类的构造器方法" class="headerlink" title="2.4.2 调用类的构造器方法"></a>2.4.2 调用类的构造器方法</h2><p>public class Person {</p>
<p>public Person(){ &#x2F;&#x2F;无参构造器方法</p>
<p>this(“Hello!”);</p>
<p>}</p>
<p>public Person(String name){ &#x2F;&#x2F;定义一个带形式参数的构造方法</p>
<p>}</p>
<p>}</p>
<p>在上述代码中，定义了两个构造方法，一个带参数，另一个没有带参数。在第一个没有带参数的构造方法中，使用了this(“Hello!”)这句代码，这句代码表示什么含义呢?在构造方法中使this关键字表示调用类中的构造方法。</p>
<p>如果一个类中有多个构造方法，因为其名字都相同，跟类名一致，那么这个this到底是调用哪个构造方法呢?其实，这跟采用其他方法引用构造方法一样，都是通过形式参数来调用构造方法的。</p>
<p>注意的是：利用this关键字来调用构造方法，只有在无参数构造方法中第一句使用this调用有参数的构造方法。否则的话，翻译的时候，就会有错误信息。这跟引用成员变量不同。如果引用成员变量的话，this 关键字是没有位置上的限制的。</p>
<h2 id="2-4-3-返回对象的引用"><a href="#2-4-3-返回对象的引用" class="headerlink" title="2.4.3 返回对象的引用"></a>2.4.3 返回对象的引用</h2><p>public HttpConfig url(String url) {</p>
<p>urls.set(url);</p>
<p>&#x2F;&#x2F;return this就是返回当前对象的引用(就是实际调用这个方法的实例化对象)</p>
<p>return this;</p>
<p>}</p>
<p>return this就是返回当前对象的引用(就是实际调用这个方法的实例化对象)，就像我们平时使用 StringBuilder一样，可以一直 ( {}^{.;} ) append ( ○ ) ，因为每次调用，返回的都是该对象的引用。</p>
<p>关于关键字，这篇文章就总结这么多，如有错误，欢迎指正，我们一起进步。</p>
<h1 id="3-Java的三大特性详解"><a href="#3-Java的三大特性详解" class="headerlink" title="3. Java的三大特性详解"></a>3. Java的三大特性详解</h1><h2 id="3-1-封装"><a href="#3-1-封装" class="headerlink" title="3.1 封装"></a>3.1 封装</h2><h2 id="3-1-1-public、private、protected修饰符"><a href="#3-1-1-public、private、protected修饰符" class="headerlink" title="3.1.1 public、private、protected修饰符"></a>3.1.1 public、private、protected修饰符</h2><p>说到封装，Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。我们先来看下这三个修饰符的作用。</p>
<table><thead><tr><th>修饰符</th><th>当前类</th><th>同包</th><th>子类</th><th>其他包</th></tr></thead><tr><td>public</td><td>\( \sqrt{} \)</td><td>\( \sqrt{} \)</td><td>\( \sqrt{} \)</td><td>\( \sqrt{} \)</td></tr><tr><td>protected</td><td>\( \sqrt{} \)</td><td>\( \sqrt{} \)</td><td>\( \sqrt{} \)</td><td>\( \times \)</td></tr><tr><td>default</td><td>\( \sqrt{} \)</td><td>\( \sqrt{} \)</td><td>\( \times \)</td><td>\( \times \)</td></tr><tr><td>private</td><td>\( \sqrt{} \)</td><td>\( \times \)</td><td>\( \times \)</td><td>\( \times \)</td></tr></table>

<p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p>
<p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。</p>
<h2 id="3-1-2-规范"><a href="#3-1-2-规范" class="headerlink" title="3.1.2 规范"></a>3.1.2 规范</h2><p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。</p>
<p>public class AccessExample {</p>
<p>public String id;</p>
<p>}</p>
<p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p>
<p>public class AccessExample {</p>
<p>private int id;</p>
<p>public string ( \operatorname{getId()}{ )</p>
<p>return ( \mathrm + ) “”;</p>
<p>}</p>
<p>public void setId(String id) {</p>
<p>this.id ( &#x3D; ) Integer.valueOf(id);</p>
<p>}</p>
<p>}</p>
<h2 id="3-1-3-封装的好处"><a href="#3-1-3-封装的好处" class="headerlink" title="3.1.3 封装的好处"></a>3.1.3 封装的好处</h2><ol>
<li><p>提高数据的安全性。</p>
</li>
<li><p>操作简单。</p>
</li>
<li><p>隐藏了实现。</p>
</li>
</ol>
<h2 id="3-2-继承"><a href="#3-2-继承" class="headerlink" title="3.2 继承"></a>3.2 继承</h2><p>继承是类与类的一种关系，是一种“is a”的关系。比如“狗”继承“动物”，这里动物类是狗类的父类或者基类，狗类是动物类的子类或者派生类。如下图所示:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/java/2.jpg" alt="2"> 父类、基类子类、派生类</p>
<p>注: java中的继承是单继承，即一个类只有一个父类。</p>
<h2 id="3-2-1-继承的初始化顺序"><a href="#3-2-1-继承的初始化顺序" class="headerlink" title="3.2.1 继承的初始化顺序"></a>3.2.1 继承的初始化顺序</h2><ol>
<li><p>初始化父类再初始化子类</p>
</li>
<li><p>先执行初始化对象中属性，再执行构造方法中的初始化。</p>
</li>
</ol>
<p>基于上面两点，我们就知道实例化一个子类，java程序的执行顺序是:</p>
<p>父类对象属性初始化—-&gt;父类对象构造方法—-&gt;子类对象属性初始化—&gt;子类对象构造方法继承这块大家都比较熟，我来举个例子:</p>
<h2 id="3-2-2-继承示例"><a href="#3-2-2-继承示例" class="headerlink" title="3.2.2 继承示例"></a>3.2.2 继承示例</h2><p>Animal动物:</p>
<p>public class Animal {</p>
<p>&#x2F;*<em>名称</em>&#x2F;</p>
<p>public String name;</p>
<p>&#x2F;*<em>颜色</em>&#x2F;</p>
<p>public string color;</p>
<p>&#x2F;*<em>显示信息</em>&#x2F;</p>
<p>public void show(){</p>
<p>System.out.println(“名称: “+name+”, 颜色: “+color);</p>
<p>}</p>
<p>}</p>
<p>&#x2F;*<em>狗继承自动物, 子类 is a 父类</em>&#x2F;</p>
<p>public class Dog extends Animal {</p>
<p>&#x2F;*<em>价格</em>&#x2F;</p>
<p>public double price;</p>
<p>}</p>
<p>dog并没有定义color属性，但在使用中可以调用，是因为dog继承了父类Animal，父类的非私有成员将被子类继承。如果再定义其它的动物类则无须再反复定义name，color与show方法。</p>
<h2 id="3-3-多态"><a href="#3-3-多态" class="headerlink" title="3.3 多态"></a>3.3 多态</h2><p>多态这块，我要跟大家好好唠叨唠叨，首先来看下概念:</p>
<h2 id="3-3-1-多态概念"><a href="#3-3-1-多态概念" class="headerlink" title="3.3.1 多态概念"></a>3.3.1 多态概念</h2><p>多态: 一个对象具备多种形态。</p>
<p>①父类的引用类型变量指向了子类的对象</p>
<p>②接口的引用类型变量指向了接口实现类的对象</p>
<p>多态的前提: 必须存在继承或者实现关系。</p>
<p>动物 ( a &#x3D; ) new 狗 ( O ) ;</p>
<h2 id="3-3-2-多态要注意的细节"><a href="#3-3-2-多态要注意的细节" class="headerlink" title="3.3.2 多态要注意的细节"></a>3.3.2 多态要注意的细节</h2><ol>
<li><p>多态情况下，子父类存在同名的成员变量时，访问的是父类的成员变量。</p>
</li>
<li><p>多态情况下，子父类存在同名的非静态的成员函数时，访问的是子类的成员函数。</p>
</li>
<li><p>多态情况下，子父类存在同名的静态的成员函数时，访问的是父类的成员函数。</p>
</li>
<li><p>多态情况下，不能访问子类特有的成员。</p>
</li>
</ol>
<p>总结: 多态情况下，子父类存在同名的成员时，访问的都是父类的成员，除了在同名非静态函数时才是访问子类的。</p>
<p>注意：java编译器在编译的时候，会检查引用类型变量所属的类是否具备指定的成员，如果不具备马上编译报错。（编译看左边）</p>
<h2 id="3-3-3-多态的应用"><a href="#3-3-3-多态的应用" class="headerlink" title="3.3.3 多态的应用"></a>3.3.3 多态的应用</h2><ol>
<li><p>多态用于形参类型的时候，可以接收更多类型的数据。</p>
</li>
<li><p>多态用于返回值类型的时候，可以返回更多类型的数据。</p>
</li>
</ol>
<p>多态的好处：提高了代码的拓 展性。</p>
<p>我们想想，平时写MVC三层模型的时候，service为什么要写接口呢？因为可能有个service会有多种不同的实现。service就是我们平时用多态最多的地方。</p>
<h1 id="4-Java-中的-String-详解"><a href="#4-Java-中的-String-详解" class="headerlink" title="4. Java 中的 String 详解"></a>4. Java 中的 String 详解</h1><h2 id="4-1-看看源码"><a href="#4-1-看看源码" class="headerlink" title="4.1 看看源码"></a>4.1 看看源码</h2><p>大家都知道，String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承) 。我们先来看看 String 的源码。</p>
<p>在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<p>public final class string</p>
<p>implements java.io.serializable, Comparable<String>, Charsequence {</p>
<p>&#x2F;** The value is used for character storage. *&#x2F;</p>
<p>private final char value[];</p>
<p>}</p>
<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。</p>
<p>public final class String</p>
<p>implements java.io.serializable, Comparable<String>, Charsequence {</p>
<p>&#x2F;** The value is used for character storage. *&#x2F;</p>
<p>private final byte[] value;</p>
<p>&#x2F;** The identifier of the encoding used to encode the bytes in {@code value}.</p>
<p>*&#x2F;</p>
<p>private final byte coder;</p>
<p>}</p>
<p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
<h2 id="4-2-不可变有什么好处呢"><a href="#4-2-不可变有什么好处呢" class="headerlink" title="4.2 不可变有什么好处呢"></a>4.2 不可变有什么好处呢</h2><h2 id="4-2-1-可以缓存-hash-值"><a href="#4-2-1-可以缓存-hash-值" class="headerlink" title="4.2.1 可以缓存 hash 值"></a>4.2.1 可以缓存 hash 值</h2><p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p>
<h2 id="4-2-2-String-Pool-的使用"><a href="#4-2-2-String-Pool-的使用" class="headerlink" title="4.2.2 String Pool 的使用"></a>4.2.2 String Pool 的使用</h2><p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的， 才可能使用 String Pool。</p>
<h2 id="4-2-3-安全性"><a href="#4-2-3-安全性" class="headerlink" title="4.2.3 安全性"></a>4.2.3 安全性</h2><p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p>
<h2 id="4-2-4-线程安全"><a href="#4-2-4-线程安全" class="headerlink" title="4.2.4 线程安全"></a>4.2.4 线程安全</h2><p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>
<h2 id="4-3-再来深入了解一下-String"><a href="#4-3-再来深入了解一下-String" class="headerlink" title="4.3 再来深入了解一下 String"></a>4.3 再来深入了解一下 String</h2><h2 id="4-3-1-“-”-连接符"><a href="#4-3-1-“-”-连接符" class="headerlink" title="4.3.1 “+” 连接符"></a>4.3.1 “+” 连接符</h2><p>字符串对象可以使用“+”连接其他对象，其中字符串连接是通过 StringBuilder（或 StringBuffer）类及其 append 方法实现的，对象转换为字符串是通过 toString 方法实现的。可以通过反编译验证一下:</p>
<hr>
<p>&#x2F;**</p>
<ul>
<li>测试代码</li>
</ul>
<p>*&#x2F;</p>
<p>public class Test {</p>
<p>public static void main(String[] args) {</p>
<p>int ( i &#x3D; {10} ) ;</p>
<p>String ( s &#x3D; ) “abc”;</p>
<p>System.out.println(s + i);</p>
<p>}</p>
<p>}</p>
<p>&#x2F;**</p>
<ul>
<li>反编译后</li>
</ul>
<p>*&#x2F;</p>
<p>public class Test {</p>
<p>public static void main(String args[]) { &#x2F;&#x2F;删除了默认构造函数和字节码</p>
<p>byte byte0 ( &#x3D; {10} ) ;</p>
<p>String ( s &#x3D; ) “abc”;</p>
<p>System.out.println((new</p>
<p>StringBuilder()).append(s).append(byte0).toString());</p>
<p>}</p>
<p>}</p>
<hr>
<p>由上可以看出，Java中使用”+”连接字符串对象时，会创建一个StringBuilder()对象，并调用append()方法将数据拼接，最后调用toString()方法返回拼接好的字符串。那这个 “+” 的效率怎么样呢?</p>
<h2 id="4-3-2-“-”连接符的效率"><a href="#4-3-2-“-”连接符的效率" class="headerlink" title="4.3.2 “+”连接符的效率"></a>4.3.2 “+”连接符的效率</h2><p>使用“+”连接符时，JVM会隐式创建StringBuilder对象，这种方式在大部分情况下并不会造成效率的损失，不过在进行大量循环拼接字符串时则需要注意。比如：</p>
<p>String ( s &#x3D; ) “abc”;</p>
<p>for (int i&#x3D;0; i&lt;10000; i++) {</p>
<p>( \mathrm{s} + &#x3D; ) “abc”;</p>
<p>}</p>
<p>这样由于大量StringBuilder创建在堆内存中，肯定会造成效率的损失，所以在这种情况下建议在循环体外创建一个StringBuilder对象调用append()方法手动拼接（如上面例子如果使用手动拼接运行时间将缩小到1&#x2F;200左右）。</p>
<p>与此之外还有一种特殊情况，也就是当”+”两端均为编译期确定的字符串常量时，编译器会进行相应的优化，直接将两个字符串常量拼接好，例如:</p>
<p>System.out.println(“Hello” + “world”);</p>
<p>&#x2F;**</p>
<ul>
<li>反编译后</li>
</ul>
<p>*&#x2F;</p>
<p>System.out.println(“Helloworld”);</p>
<h2 id="4-4-字符串常量"><a href="#4-4-字符串常量" class="headerlink" title="4.4 字符串常量"></a>4.4 字符串常量</h2><p>JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于 String字符串的不可变性，常量池中一定不存在两个相同的字符串。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/java/3.jpg" alt="3"></p>
<p>我们来看一个例子:</p>
<p>&#x2F;**</p>
<ul>
<li>运行结果为true false</li>
</ul>
<p>*&#x2F;</p>
<p>String ( {s1} &#x3D; ) “abc”;</p>
<p>string ( {s2} &#x3D; ) “abc”;</p>
<p>String ( {s3} &#x3D; ) new String(“abc”);</p>
<p>System.out.println(s1 &#x3D;&#x3D; s2);</p>
<p>System.out.println(s1 &#x3D;&#x3D; s3);</p>
<p>由于常量池中不存在两个相同的对象，所以s1和s2都是指向JVM字符串常量池中的”AB”对象。new关键字一定会产生一个对象，并且这个对象存储在堆中。所以string s3 &#x3D; new string(“AB”); 产生了两个对象：保存在栈中的s3和保存堆中的String对象。</p>
<h1 id="5-StringBuffer-和-StringBuilder-详解"><a href="#5-StringBuffer-和-StringBuilder-详解" class="headerlink" title="5. StringBuffer 和 StringBuilder 详解"></a>5. StringBuffer 和 StringBuilder 详解</h1><p>StringBuilder 和 StringBuffer 的问题已经是老生常谈了，但是为什么还有那么多面试官喜欢问这个问题呢? 不知道，我觉得是面试官太low了……</p>
<p>不过我也来把这个知识点给大家总结一下，先说说他们的相同点。</p>
<h2 id="5-1-相同点"><a href="#5-1-相同点" class="headerlink" title="5.1 相同点"></a>5.1 相同点</h2><p>说到这单，我又忍不住要跟大家唠叨唠叨 String 了，我们先看下 String 的一个例子:</p>
<p>String a &#x3D; “123”;</p>
<p>a ( &#x3D; ) “456”;</p>
<p>&#x2F;&#x2F; 打印出来的a为456</p>
<p>System.out.println(a)</p>
<p>不是说 String 是不可改变的吗? 这怎么就变了呢? 逗我吗? 其实是没变的，原来那个 123 没变，相当于重新创建了一个 456，然后把 a 指向了这个 456，那个 123 会被回收掉。看看我给大家画的图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/java/4.jpg" alt="4"></p>
<p>而 StringBuffer 和 StringBuilder 就不一样了，他们是可变的，当一个对象被创建以后，通过 append()、insert()、reverse()、setcharAt()、setLength()等方法可以改变这个字符串对象</p>
<p>的字符序列。也来看个例子:</p>
<p>StringBuffer ( b &#x3D; ) new StringBuffer(“123”);</p>
<p>b.append(“456”);</p>
<p>&#x2F;&#x2F; b打印结果为: 123456</p>
<p>System.out.println(b);</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/java/5.jpg" alt="5"></p>
<p>OK，那现在我们知道了，StringBuffer 和 StringBuilder 有个共同点，那就是它们代表一个字符可变的字符串。那除此之外，还有没有其他相同点呢?</p>
<p>肯定是有的，比如:</p>
<ol>
<li><p>StringBuilder 与 StringBuffer 有公共父类 AbstractStringBuilder (抽象类);</p>
</li>
<li><p>StringBuilder、StringBuffer 的方法都会调用 AbstractStringBuilder 中的公共方法，如 super.append(…)。</p>
</li>
</ol>
<h2 id="5-2-不同点"><a href="#5-2-不同点" class="headerlink" title="5.2 不同点"></a>5.2 不同点</h2><p>StringBuffer 是线程安全的，StringBuilder 是非线程安全的。我们看源码都知道，StringBuffer 的方法上面都加了 synchronized 关键字，所以没有线程安全问题，但是性能会受影响，所以 StringBuilder 会比 StringBuffer 快，在单线程环境下，建议使用 StringBuilder。</p>
<p>另外还有个不同点是缓冲区。</p>
<p>先看下 StringBuilder 的 tostring() 方法:</p>
<p>@override</p>
<p>public string toString() {</p>
<p>&#x2F;&#x2F; Create a copy, don’t share the array</p>
<p>return new String(value, 0, count);</p>
<p>}</p>
<p>再看下 StringBuffer 的 tostring () 方法:</p>
<p>@override</p>
<p>public synchronized String toString() {</p>
<p>if (tostringCache ( &#x3D; &#x3D; ) null) {</p>
<p>toStringCache ( &#x3D; ) Arrays.copyOfRange(value, 0, count);</p>
<p>}</p>
<p>return new String(toStringCache, true);</p>
<p>}</p>
<p>可以看出：StringBuffer 每次获取 toString 都会直接使用缓存区的 toStringCache 值来构造一个字符串。而 StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串。</p>
<p>所以，StringBuffer 对缓存区优化，不过 StringBuffer 的这个toString 方法仍然是同步的。</p>
<p>OK，StringBuffer 和 StringBuilder 就总结这么多吧，如有问题，欢迎指正。</p>
<h1 id="6-Java-反射详解"><a href="#6-Java-反射详解" class="headerlink" title="6. Java 反射详解"></a>6. Java 反射详解</h1><p>反射是框架设计的灵魂要素！</p>
<h2 id="6-1-反射是什么"><a href="#6-1-反射是什么" class="headerlink" title="6.1 反射是什么?"></a>6.1 反射是什么?</h2><p>所谓的反射就是java语言在运行时拥有的一种自观的能力,反射使您的程序代码能够得到装载到VM中的类的内部信息,允许您执行程序时才得到需要类的内部信息，而不是在编写代码的时候就必须要知道所需类的内部信息;也可以通俗的将这种动态获取信息以及动态调用对象的方法称为Java的反射机制.</p>
<p>通过Java的反射机制,程序猿们可以更深入的控制程序的运行过程,如在程序运行时对用户输入的信息进行验证,还可以逆向控制程序的执行过程，这也使反射成为构建灵活的应用的主要工具。</p>
<h2 id="6-2-反射原理大解析"><a href="#6-2-反射原理大解析" class="headerlink" title="6.2 反射原理大解析"></a>6.2 反射原理大解析</h2><h2 id="6-2-1-反射的常用类和函数"><a href="#6-2-1-反射的常用类和函数" class="headerlink" title="6.2.1 反射的常用类和函数"></a>6.2.1 反射的常用类和函数</h2><p>Java反射机制的实现要借助于4个类:</p>
<ul>
<li><p>Class 类对象</p>
</li>
<li><p>Constructor 类的构造器对象</p>
</li>
<li><p>Field 类的属性对象</p>
</li>
<li><p>Method 类的方法对象</p>
</li>
</ul>
<h2 id="6-2-2-Class-类包含的方法"><a href="#6-2-2-Class-类包含的方法" class="headerlink" title="6.2.2 Class 类包含的方法"></a>6.2.2 Class 类包含的方法</h2><p>通过这四个对象我们可以粗略的看到一个类的各个组成部分。其中最核心的就是Class类，它是实现反射的基础，Class类包含的方法主要有:</p>
<table><thead><tr><th>序号</th><th>名称</th><th>功能</th></tr></thead><tr><td>1</td><td>getName()</td><td>获取此类型的全限定名</td></tr><tr><td>2</td><td>getSuperClass()</td><td>得到此类型的直接超类的全限定名</td></tr><tr><td>3</td><td>isInterface()</td><td>判断此类型是类类型还是接口类型</td></tr><tr><td>4</td><td>getTypeParamters()</td><td>获取这个类型的访问修饰符</td></tr><tr><td>5</td><td>getInterfaces()</td><td>获取任何直接超接口的全限定名的有序列表</td></tr><tr><td>6</td><td>getFields()</td><td>获取字段信息</td></tr><tr><td>7</td><td>getMethods()</td><td>获取方法信息</td></tr></table>



<h2 id="6-2-3-反射的主要方法"><a href="#6-2-3-反射的主要方法" class="headerlink" title="6.2.3 反射的主要方法"></a>6.2.3 反射的主要方法</h2><p>应用反射时我们最关心的一般是一个类的构造器、属性和方法，下面我们主要介绍Class类中针对这三个元素的方法:</p>
<h2 id="6-2-3-1-得到构造器的方法"><a href="#6-2-3-1-得到构造器的方法" class="headerlink" title="6.2.3.1 得到构造器的方法"></a>6.2.3.1 得到构造器的方法</h2><table><thead><tr><th>语法</th><th>功能</th></tr></thead><tr><td>Constructor getConstructor(Class[] params)</td><td>获得使用特殊的参数类型的公共构造函数</td></tr><tr><td>Constructor[] getConstructors()</td><td>获得类的所有公共构造函数</td></tr><tr><td>Constructor getDeclaredConstructor(Class[] params)</td><td>获得使用特定参数类型的构造函数(与接入 级别无关）</td></tr><tr><td>Constructor[] getDeclaredConstructors()</td><td>获得类的所有构造函数(与接入级别无关)</td></tr></table>

<h2 id="6-2-3-2-获得字段信息的方法"><a href="#6-2-3-2-获得字段信息的方法" class="headerlink" title="6.2.3.2 获得字段信息的方法"></a>6.2.3.2 获得字段信息的方法</h2><table><thead><tr><th>语法</th><th>功能</th></tr></thead><tr><td>Field getField(String name)</td><td>获得命名的公共字段</td></tr><tr><td>Field[] getFields()</td><td>获得类的所有公共字段</td></tr><tr><td>Field getDeclaredField(String name)</td><td>获得类声明的命名的字段</td></tr><tr><td>Field[] getDeclaredFields()</td><td>获得类声明的所有字段</td></tr></table>

<h2 id="6-2-3-3-获得方法信息的方法"><a href="#6-2-3-3-获得方法信息的方法" class="headerlink" title="6.2.3.3 获得方法信息的方法"></a>6.2.3.3 获得方法信息的方法</h2><table><thead><tr><th>语法</th><th>功能</th></tr></thead><tr><td>Method getMethod(String name, Class[] params)</td><td>使用特定的参数类型，获得命名的公共 方法</td></tr><tr><td>Method[] getMethods()</td><td>获得类的所有公共方法</td></tr><tr><td>Method getDeclaredMethod(String name, Class[] params)</td><td>使用特写的参数类型，获得类声明的命 名的方法</td></tr><tr><td>Method[] getDeclaredMethods()</td><td>获得类声明的所有方法</td></tr></table>

<h2 id="6-2-4-反射实战的基本步骤"><a href="#6-2-4-反射实战的基本步骤" class="headerlink" title="6.2.4 反射实战的基本步骤"></a>6.2.4 反射实战的基本步骤</h2><p>Class actionClass&#x3D;Class.forName(“MyClass”);</p>
<p>Object action&#x3D;actionClass.newInstance();</p>
<p>Method method ( &#x3D; ) actionClass.getMethod(“myMethod”, null);</p>
<p>method.invoke(action, null);</p>
<p>上面就是最常见的反射使用的例子，前两行实现了类的装载、链接和初始化（newInstance方法实际上也是使用反射调用了<init>方法），后两行实现了从class对象中获取到method对象然后执行反射调用。下面简单分析一下该代码的具体原理。</p>
<h2 id="6-2-4-1-获得类的Class对象"><a href="#6-2-4-1-获得类的Class对象" class="headerlink" title="6.2.4.1 获得类的Class对象"></a>6.2.4.1 获得类的Class对象</h2><p>通常有三种不同的方法:</p>
<ol>
<li><p>Class ( \mathrm{c} &#x3D; ) Class.forName(“java.lang.String”)</p>
</li>
<li><p>Class ( \mathrm{c} &#x3D; ) MyClass.class</p>
</li>
<li><p>对于基本数据类型可以用Class ( \mathrm{c} &#x3D; ) int.class 或 Class ( \mathrm{c} &#x3D; ) Integer.TYPE这样的语句.</p>
</li>
</ol>
<p>举个小栗子：先通过反射机制得到某个类的构造器，然后调用该构造器创建该类的一个实例</p>
<p>PS：反射的原理之一其实就是动态的生成类似于上述的字节码，加载到jvm中运行。</p>
<p>设想一下，上面的代码中，如果想要实现 method. invoke (action, null) 调用action对象的 myMethod 方法,只需要实现这样一个Method类即可:</p>
<p>class Method{</p>
<p>public Object invoke(Object obj, Object[] param){</p>
<p>MyClass myClass&#x3D;(MyClass)obj;</p>
<p>return myClass.myMethod();</p>
<p>}</p>
<p>}</p>
<h2 id="6-2-4-2-获取-Method-对象"><a href="#6-2-4-2-获取-Method-对象" class="headerlink" title="6.2.4.2 获取 Method 对象"></a>6.2.4.2 获取 Method 对象</h2><p>首先来看一下Method对象是如何生成的:</p>
<ul>
<li><p>使用Method m &#x3D;myclass.getMethod(“myMethod”)获得了一个Class对象</p>
</li>
<li><p>接着对其进行判断,如果没有对应的cache,那么JVM就会为其创建一个并放入缓冲空间</p>
</li>
<li><p>处理器再判断Cache中是否存在”myMethod”</p>
</li>
<li><p>如果没有则返回NoSuchMethodException</p>
</li>
<li><p>如果存在那么就Copy一份”myMethod”对象并返回</p>
</li>
</ul>
<p>上面的Class对象是在加载类时由JVM构造的，JVM为每个类管理一个独一无二的Class对象，这份Class对象里维护着该类的所有Method，Field，Constructor的cache，这份cache也可以被称作根对象。每次 getMethod获取到的Method对象都持有对根对象的引用，因为一些重量级的Method的成员变量（主要是MethodAccessor），我们不希望每次创建Method对象都要重新初始化，于是所有代表同一个方法的 Method对象都共享着根对象的MethodAccessor，每一次创建都会调用根对象的copy方法复制一份：</p>
<p>Method copy() {</p>
<p>Method res &#x3D; new Method(clazz, name, parameterTypes, returnType,</p>
<p>exceptionTypes, modifiers, slot, signature,</p>
<p>annotations, parameterAnnotations,</p>
<p>annotationDefault);</p>
<p>res.root ( &#x3D; ) this;</p>
<p>res.methodAccessor ( &#x3D; ) methodAccessor;</p>
<p>return res;</p>
<h2 id="6-2-4-3-调用invoke-方法"><a href="#6-2-4-3-调用invoke-方法" class="headerlink" title="6.2.4.3 调用invoke()方法"></a>6.2.4.3 调用invoke()方法</h2><p>获取到Method对象之后，调用invoke方法的流程如下:</p>
<p>m.invoke(obj, param);</p>
<ul>
<li><p>首先调用MethodAccess.invoke</p>
</li>
<li><p>如果该方法的累计调用次数&lt;&#x3D;15，会创建出NativeMethodAccessorImp</p>
</li>
<li><p>如果该方法的累计调用次数 ( &gt; {15} ) ，会由java代码创建出字节码组装而成的</p>
</li>
</ul>
<p>MethodAccessorImpl</p>
<p>我们可以看到，调用Method.invoke之后，会直接去调 MethodAccessor.invoke 。MethodAccessor就是上面提到的所有同名method共享的一个实例，由ReflectionFactory创建。创建机制采用了一种名为 inflation的方式 (JDK1.4之后) : 如果该方法的累计调用次数&lt;&#x3D;15, 会创建出</p>
<p>NativeMethodAccessorImpl，它的实现就是直接调用native方法实现反射；如果该方法的累计调用次数 &gt;15，会由java代码创建出字节码组装而成的MethodAccessorImpl。（是否采用inflation和15这个数字都可以在jvm参数中调整)</p>
<p>以调用 MyClass.myMethod(String s) 为例，生成出的MethodAccessorImpl字节码翻译成Java代码大致如下:</p>
<p>public class GeneratedMethodAccessor1 extends MethodAccessorImpl {</p>
<p>public Object invoke(Object obj, Object[] args) throws Exception {</p>
<p>try ( { )</p>
<p>MyClass target ( &#x3D; ) (MyClass) obj;</p>
<p>String arg0 &#x3D; (String) args[0];</p>
<p>target.myMethod(arg0);</p>
<p>} catch (Throwable t) {</p>
<p>throw new InvocationTargetException(t);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>通过对java运行过程的详细分析，我们可以发现其中第1次和第16次调用是最耗时的(初始化 NativeMethodAccessorImpl和字节码拼装MethodAccessorImpl)。初始化不可避免，因而native方式的初始化会更快，所以前几次的调用会采用native方法。</p>
<p>随着调用次数的增加，每次反射都使用JNI跨越native边界会对优化有阻碍作用，相对来说使用拼装出的字节码可以直接以Java调用的形式实现反射，发挥了JIT优化的作用，避免了JNI为了维护OopMap （HotSpot用来实现准确式GC的数据结构）进行封装&#x2F;解封装的性能损耗。</p>
<p>在已经创建了MethodAccessor的情况下，使用Java版本的实现会比native版本更快。所以当调用次数到达一定次数（15次）后，会切换成Java实现的版本，来优化未来可能的更频繁的反射调用。</p>
<h2 id="6-3-Java反射的应用-Hibernate框架"><a href="#6-3-Java反射的应用-Hibernate框架" class="headerlink" title="6.3 Java反射的应用(Hibernate框架)"></a>6.3 Java反射的应用(Hibernate框架)</h2><p>前面我们已经知道，Java 反射机制提供了一种动态链接程序组件的多功能方法，它允许程序创建和控制任何类的对象(根据安全性限制)之前，无需提前硬编码目标类。这些特性使得反射特别适用于创建以非常普通的方式与对象协作的库。例如，反射经常在持续存储对象为数据库、XML或其它外部格式的框架中使用。下面就已Hibernate框架为例像大家阐述一下反射的重要意义。</p>
<p>Hibernate是一个屏蔽了JDBC，实现了ORM的java框架，利用该框架我们可以抛弃掉繁琐的sql语句而是利用Hibernate中Session类的save()方法直接将某个类的对象存到数据库当中,也就是所涉及到sql语句的那些代码Hibernate帮我们做了。这时候就出现了一个问题, Hibernate怎样知道他要存的某个对象都有什么属性呢？这些属性都是什么类型呢？想一想,它在向数据库中存储该对象属性时的sql语句该怎么构造</p>
<p>呢? OK,反射的作用此刻就体现出来了!</p>
<p>下面我们以一个例子来进行阐述，比如我们定义了一个User类，这个User类中有20个属性和这些属性的 get和set方法，相应的在数据库中有一个User表，这个User表中对应着20个字段。假设我们从User表中提取了一条记录，现在需要将这条记录的20个字段的内容分别赋给一个User对象myUser的20个属性， 而Hibernate框架在编译的时候并不知道这个User类，他无法直接调用myUser.getXXX或者 myUser.setXXX方法，此时就用到了反射，具体处理过程如下:</p>
<ol>
<li><p>根据查询条件构造PreparedStament语句，该语句返回20个字段的值;</p>
</li>
<li><p>Hibernate通过读取配置文件得到User类的属性列表list(是一个String数组)以及这些属性的类型；</p>
</li>
<li><p>创建myUser所属类的Class对象c; ( \mathrm{c} &#x3D; ) myUser.getClass();</p>
</li>
<li><p>构造一个for循环，循环的次数为list列表的长度;</p>
</li>
</ol>
<p>。 读取list[i]的值，然后构造对应该属性的set方法；</p>
<p>。判断list[i]的类型XXX，调用PreparedStament语句中的getXXX(i)，进而得到i出字段的值；</p>
<p>。 将4.2中得到的值作为4.1中得到的set方法的参数，这样就完成了一个字段像一个属性的赋值， 如此循环直至程序运行结束;</p>
<p>如果没有反射难以想象实现这么复杂的功能将会有多么难！</p>
<p>话说回来,反射给我们带来便利的同时也有它自身的缺点，比如性能较低、安全性较低、过程比较复杂等等，感兴趣的读者也可以在实际工作中再深入研究哦！</p>
<h1 id="7-Java-异常详解"><a href="#7-Java-异常详解" class="headerlink" title="7. Java 异常详解"></a>7. Java 异常详解</h1><h2 id="7-1-异常的概念"><a href="#7-1-异常的概念" class="headerlink" title="7.1 异常的概念"></a>7.1 异常的概念</h2><p>如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/java/6.jpg" alt="6"></p>
<h2 id="7-2-Java-中异常分为哪些种类"><a href="#7-2-Java-中异常分为哪些种类" class="headerlink" title="7.2 Java 中异常分为哪些种类"></a>7.2 Java 中异常分为哪些种类</h2><p>按照异常需要处理的时机分为编译时异常（也叫强制性异常）也叫CheckedException 和运行时异常（也叫非强制性异常）也叫RuntimeException。</p>
<p>只有java 语言提供了Checked 异常，Java 认为 Checked 异常都是可以被处理的异常，所以java 程序必须显式处理Checked 异常。如果程序没有处理Checked 异常，该程序在编译时就会发生错误无法编译。 这体现了Java 的设计哲学：没有完善错误处理的代码根本没有机会被执行。对Checked 异常处理方法有两种:</p>
<ol>
<li><p>当前方法知道如何处理该异常，则用try…catch 块来处理该异常。</p>
</li>
<li><p>当前方法不知道如何处理，则在定义该方法是声明抛出该异常。</p>
</li>
</ol>
<p>运行时异常只有当代码在运行时才发行的异常，编译时不需要try catch。Runtime 如除数是0 和数组下标越界等，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大。所以由系统自动检测并将它们交给缺省的异常处理程序。当然如果你有处理要求也可以显示捕获它们。</p>
<p>那么，调用下面的方法，会得到什么结果呢?</p>
<p>public int getNum(){</p>
<p>try {</p>
<p>int ( a &#x3D; 1&#x2F;0 ) ;</p>
<p>return 1 ;</p>
<p>} catch (Exception e) {</p>
<p>return 2;</p>
<p>}finally{</p>
<p>return 3;</p>
<p>}</p>
<p>}</p>
<p>代码在走到第3 行的时候遇到了一个MathException，这时第四行的代码就不会执行了，代码直接跳转到 catch语句中，走到第6 行的时候，异常机制有这么一个原则如果在catch 中遇到了return 或者异常等能使该函数终止的话那么有finally 就必须先执行完finally 代码块里面的代码然后再返回值。因此代码又跳到第 8 行，可惜第 8 行是一个return 语句，那么这个时候方法就结束了，因此第 6 行的返回结果就无法被真正返回。如果finally 仅仅是处理了一个释放资源的操作，那么该道题最终返回的结果就是2。因此上面返回值是3。</p>
<h2 id="7-3-error-和exception-有什么区别"><a href="#7-3-error-和exception-有什么区别" class="headerlink" title="7.3 error 和exception 有什么区别?"></a>7.3 error 和exception 有什么区别?</h2><p>Error 类和Exception 类的父类都是Throwable 类，他们的区别如下。</p>
<p>Error 类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等。 对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。</p>
<p>Exception 类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。</p>
<p>Exception 类又分为运行时异常 (Runtime Exception) 和受检查的异常(Checked Exception )，运行时异常；ArithmaticException, IllegalArgumentException，编译能通过，但是一运行就终止了，程序不会处理运行时异常，出现这类异常，程序会终止。而受检查的异常，要么用try。。。catch 捕获，要么用 throws 字句声明抛出，交给它的父类处理，否则编译不会通过。</p>
<h2 id="7-4-throw-和-throws-的区别是什么"><a href="#7-4-throw-和-throws-的区别是什么" class="headerlink" title="7.4 throw 和 throws 的区别是什么?"></a>7.4 throw 和 throws 的区别是什么?</h2><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和抛出异常，可以通过 throws 关键字在方法上声明该方法要抛出的异常，或者在方法内部通过 throw 抛出异常对象。</p>
<p>throws 关键字和 throw 关键字在使用上的几点区别如下:</p>
<ol>
<li><p>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</p>
</li>
<li><p>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</p>
</li>
</ol>
<h2 id="7-5-Java-的异常处理机制"><a href="#7-5-Java-的异常处理机制" class="headerlink" title="7.5 Java 的异常处理机制"></a>7.5 Java 的异常处理机制</h2><p>Java 对异常进行了分类，不同类型的异常分别用不同的Java 类表示，所有异常的根类为</p>
<p>java.lang.Throwable，Throwable 下面又派生了两个子类：Error 和Exception，Error 表示应用程序本身无法克服和恢复的一种严重问题。</p>
<p>Exception 表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题， 但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组脚本越界</p>
<p>（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常</p>
<p>（ClassCastException）；普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，</p>
<p>例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。java 为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try..catch 处理或用throws 声明继续抛给上层调用方法处理，所以普通异常也称为checked 异常，而系统异常可以处理也可以不处理，所以，编译器不强制用 try..catch 处理或用throws 声明，所以系统异常也称为unchecked 异常。</p>
<h2 id="7-6-请写出你最常见的5-个RuntimeException"><a href="#7-6-请写出你最常见的5-个RuntimeException" class="headerlink" title="7.6 请写出你最常见的5 个RuntimeException"></a>7.6 请写出你最常见的5 个RuntimeException</h2><p>这是面试过程中，很喜欢问的问题，下面列举几个常见的RuntimeException。</p>
<p>1）java.lang.NullPointerException 空指针异常；出现原因：调用了未经初始化的对象或者是不存在的对象。</p>
<p>2）java.lang.ClassNotFoundException 指定的类找不到；出现原因：类的名称和路径加载错误；通常都是程序试图通过字符串来加载某个类时可能引发异常。</p>
<p>3）java.lang.NumberFormatException 字符串转换为数字异常；出现原因：字符型数据中包含非数字型字符。</p>
<p>4）java.lang.IndexOutOfBoundsException 数组角标越界异常，常见于操作数组对象时发生。</p>
<p>5）java.lang.IllegalArgumentException 方法传递参数错误。</p>
<ol start="6">
<li>java.lang.ClassCastException 数据类型转换异常。</li>
</ol>
<p>7）java.lang.NoClassDefFoundException 未找到类定义错误。</p>
<p>8）SQLException SQL 异常，常见于操作数据库时的SQL 语句错误。</p>
<ol start="9">
<li><p>java.lang.InstantiationException 实例化异常。</p>
</li>
<li><p>java.lang.NoSuchMethodException 方法不存在异常。</p>
</li>
</ol>
<h2 id="7-7-final、finally、finalize-的区别"><a href="#7-7-final、finally、finalize-的区别" class="headerlink" title="7.7 final、finally、finalize 的区别"></a>7.7 final、finally、finalize 的区别</h2><ol>
<li><p>final：用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，被其修饰的类不可继承。</p>
</li>
<li><p>finally: 异常处理语句结构的一部分，表示总是执行。</p>
</li>
<li><p>finalize：Object 类的一个方法，在垃圾回收器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。该方法更像是一个对象生命周期的临终方法，</p>
</li>
</ol>
<p>当该方法被系统调用则代表该对象即将“死亡”，但是需要注意的是，我们主动行为上去调用该方法并不会导致该对象“死亡”，这是一个被动的方法（其实就是回调方法），不需要我们调用。</p>
<h2 id="7-8-NoClassDefFoundError-和-ClassNotFoundException-区别"><a href="#7-8-NoClassDefFoundError-和-ClassNotFoundException-区别" class="headerlink" title="7.8 NoClassDefFoundError 和 ClassNotFoundException 区别"></a>7.8 NoClassDefFoundError 和 ClassNotFoundException 区别</h2><p>NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。</p>
<p>引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是变异后被删除了等原因导致；</p>
<p>ClassNotFoundException 是一个受查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用 Class.forName, ClassLoader.loadClass 或</p>
<p>ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。</p>
<p>Java 异常 就总结这么多，如果有问题，欢迎讨论。</p>
<h1 id="8-Java-IO-流详解"><a href="#8-Java-IO-流详解" class="headerlink" title="8. Java IO 流详解"></a>8. Java IO 流详解</h1><h2 id="8-1-Java-IO概念"><a href="#8-1-Java-IO概念" class="headerlink" title="8.1 Java IO概念"></a>8.1 Java IO概念</h2><p>Java IO：即 Java 输入 &#x2F; 输出系统。</p>
<p>Java 的 IO 模型设计非常优秀，它使用 Decorator (装饰者)模式，按功能划分 stream，您可以动态装配这些 stream，以便获得您需要的功能。</p>
<p>Stream：JAVA 中将数据的输入输出抽象为流，流是一组有顺序的、单向的，有起点和终点的数据集合。按照流中的最小数据单元又分为字节流和字符流。</p>
<p>IO 流用来处理设备之间的数据传输，Java 程序中，对于数据的输入&#x2F;输出操作 都是以“流”的方式进行的。 java.io 包下提供了各种“流”类的接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。</p>
<p>对于计算机来说，数据是以二进制形式读出或写入。我们可以把文件想象为一个桶，我们通过管道将桶里的水抽出来。这里的管道也就相当于Java中的流。流的本质是一种有序的数据集合，有数据源和目的地。</p>
<h2 id="8-2-Java-IO流分类"><a href="#8-2-Java-IO流分类" class="headerlink" title="8.2 Java IO流分类"></a>8.2 Java IO流分类</h2><ol>
<li>按照流的方向 (输出输入都是站在程序所在内存的角度为依据划分的)</li>
</ol>
<p>。 输入流：只能从内存中读数据</p>
<p>。 输出流：只能向文件中写数据</p>
<p>○ 输入：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</p>
<p>。 输出：将程序（内存）数据输出到磁盘、光盘等存储设备中</p>
<table><thead><tr><th>.</th><th>字节流</th><th>字符流</th></tr></thead><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></table>

<ul>
<li><p>Inputstream: 字节输入流</p>
</li>
<li><p>OutputStream: 字节输出流</p>
</li>
<li><p>Reader: 字符输入流</p>
</li>
<li><p>Writer: 字符输出流</p>
</li>
</ul>
<p>在日常工作中，字节流一般用来处理图像，视频，以及PPT，Word类型的文件。字符流一般用于处理纯文本类型的文件，如TXT文件等，字节流可以用来处理纯文本文件，但是字符流不能用于处理图像视频等非文本类型的文件。</p>
<ol start="2">
<li>按处理数据单位(字节流与字符流)</li>
</ol>
<p>1字符 &#x3D; 2字节 、 1字节(byte) &#x3D; 8位(bit) 、 一个汉字占两个字节长度</p>
<p>。 字节流：每次读取(写出)一个字节，当传输的资源文件有中文时，就会出现乱码。</p>
<p>。 字符流：每次读取(写出)两个字节，有中文时，使用该流就可以正确传输显示中文。</p>
<ol start="3">
<li>按功能不同分为(节点流与处理流)</li>
</ol>
<p>○ 节点流：以从或向一个特定的地方 (节点) 读写数据。</p>
<ul>
<li><p>文件流: FileInputStream, FileOutputStrean, FileReader, FileWriter, 它们都会直接操作文件，直接与 OS 底层交互。因此他们被称为节点流，注意：使用这几个流的对象之后，需要关闭流对象，因为 java 垃圾回收器不会主动回收。不过在 Java7 之后，可以在 try() 括号中打开流，最后程序会自动关闭流对象，不再需要显示地 close。</p>
</li>
<li><p>数组流: ByteArrayInputStream, ByteArrayOutputStream, CharArrayReader,</p>
</li>
</ul>
<p>CharArrayWriter，对数组进行处理的节点流。</p>
<ul>
<li><p>字符串流: StringReader, StringWriter, 其中 StringReader 能从 String 中读取数据并保存到 char 数组。</p>
</li>
<li><p>管道流: PipedInputStream, PipedOutputStream, PipedReader, PipedWrite, 对管道进行处理的节点流。</p>
</li>
</ul>
<p>。 处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。</p>
<ul>
<li><p>缓冲流 : BufferedImputStrean, BufferedOutputStream, BufferedReader , BufferedWriter，需要父类作为参数构造，增加缓冲功能，避免频繁读写硬盘，可以初始化缓冲数据的大小，由于带了缓冲功能，所以就写数据的时候需要使用 flush 方法，另外，BufferedReader 提供一个 readLine( ) 方法可以读取一行，而 FileInputStream 和 FileReader 只能读取一个字节或者一个字符，因此 BufferedReader 也被称为行读取器。</p>
</li>
<li><p>转换流: InputStreamReader, OutputStreamWriter, 要 inputStream 或 OutputStream 作为参数，实现从字节流到字符流的转换，我们经常在读取键盘输入 (System.in) 或网络通信的时候，需要使用这两个类。</p>
</li>
<li><p>数据流：DataInputStream，DataOutputStream，提供将基础数据类型写入到文件中， 或者读取出来。</p>
</li>
</ul>
<p>以BufferedReader为例。处理流的构造方法总要带上一个其他的流对象做参数。一个流对象会经过其他流的多次包装。</p>
<h2 id="8-3-Java-IO流特性"><a href="#8-3-Java-IO流特性" class="headerlink" title="8.3 Java IO流特性"></a>8.3 Java IO流特性</h2><ol>
<li><p>顺序存取:可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据。（RandomAccessFile可以从文件的任意位置进行存取（输入输出）操作）</p>
</li>
<li><p>先进先出:最先写入输出流的数据最先被输入流读取到。</p>
</li>
<li><p>只读或只写：每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流。</p>
</li>
</ol>
<h2 id="8-4-Java-IO流接口"><a href="#8-4-Java-IO流接口" class="headerlink" title="8.4 Java IO流接口"></a>8.4 Java IO流接口</h2><ol>
<li><p>File（文件特征与管理）：File类是对文件系统中文件以及文件夹进行封装的对象，可以通过对象的思想来操作文件和文件夹。 File类保存文件或目录的各种元数据信息，包括文件名、文件长度、最后修改时间、是否可读、获取当前文件的路径名，判断指定文件是否存在、获得当前目录中的文件列表，创建、删除文件和目录等方法。</p>
</li>
<li><p>InputStream（二进制）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。</p>
</li>
<li><p>OutputStream（二进制）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。</p>
</li>
<li><p>Reader (文件格式) : 抽象类，基于字符的输入操作。</p>
</li>
<li><p>Writer (文件格式) : 抽象类，基于字符的输出操作。</p>
</li>
<li><p>RandomAccessFile（随机文件）：一个独立的类，直接继承至Object.它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作。</p>
</li>
</ol>
<p>一个接口指的是Serializable.掌握了这些IO的核心操作那么对于Java中的IO体系也就有了一个初步的认识了。</p>
<h2 id="8-5-Java-IO流对象"><a href="#8-5-Java-IO流对象" class="headerlink" title="8.5 Java IO流对象"></a>8.5 Java IO流对象</h2><h2 id="8-5-1-输入字节流InputStream"><a href="#8-5-1-输入字节流InputStream" class="headerlink" title="8.5.1 输入字节流InputStream"></a>8.5.1 输入字节流InputStream</h2><ol>
<li><p>ByteArrayInputStream：字节数组输入流，该类的功能就是从字节数组(byte[])中进行以字节为单位的读取，也就是将资源文件都以字节的形式存入到该类中的字节数组中。</p>
</li>
<li><p>PipedInputStream：管道字节输入流，它和PipedOutputStream一起使用，能实现多线程间的管道通信。</p>
</li>
<li><p>FilterInputStream : 装饰者模式中处于装饰者，具体的装饰者都要继承它，所以在该类的子类下都是用来装饰别的流的，也就是处理类。具体装饰者模式在下面会讲解到，到时就明白了。</p>
</li>
<li><p>BufferedInputStream: 缓冲流，对处理流进行装饰，增强，内部会有一个缓存区，用来存放字节，每次都是将缓存区存满然后发送，而不是一个字节或两个字节这样发送。效率更高。</p>
</li>
<li><p>DataInputStream：数据输入流，它是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。</p>
</li>
<li><p>FileInputSream: 文件输入流。它通常用于对文件进行读取操作。</p>
</li>
<li><p>File：对指定目录的文件进行操作，具体可以查看讲解File的博文。注意，该类虽然是在IO包下，但是并不继承自四大基础类。</p>
</li>
<li><p>ObjectInputStream：对象输入流，用来提供对“基本数据或对象”的持久存储。在反序列化中使用。</p>
</li>
</ol>
<h2 id="8-5-2-输出字节流OutputStream"><a href="#8-5-2-输出字节流OutputStream" class="headerlink" title="8.5.2 输出字节流OutputStream"></a>8.5.2 输出字节流OutputStream</h2><ol>
<li><p>OutputStream 是所有的输出字节流的父类，它是一个抽象类。</p>
</li>
<li><p>ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。PipedOutputStream 是向与其它线程共用的管道中写入数据。</p>
</li>
<li><p>ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流，同样在序列化中使用。</p>
</li>
</ol>
<h2 id="8-5-3-字符输入流-Reader"><a href="#8-5-3-字符输入流-Reader" class="headerlink" title="8.5.3 字符输入流 Reader"></a>8.5.3 字符输入流 Reader</h2><ol>
<li><p>Reader : 所有的输入字符流的父类，它是一个抽象类。</p>
</li>
<li><p>CharReader 、StringReader：两种基本的介质流，它们分别将Char 数组、String中读取数据。 PipedReader 是从与其它线程共用的管道中读取数据。</p>
</li>
<li><p>BufferedReader : 一个装饰器，它和其子类负责装饰其它Reader 对象。</p>
</li>
<li><p>FilterReader: 所有自定义具体装饰流的父类，其子类PushbackReader 对Reader 对象进行装饰，会增加一个行号。</p>
</li>
<li><p>InputstreamReader : 一个连接字节流和字符流的桥梁，它将字节流转变为字符流。 FileReader 可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为 Reader 的方法。我们可以从这个类中得到一定的技巧。Reader 中各个类的用途和使用方法基本和 InputStream 中的类使用一致。后面会有Reader 与InputStream 的对应关系。</p>
</li>
</ol>
<h2 id="8-5-4-字符输出流Writer"><a href="#8-5-4-字符输出流Writer" class="headerlink" title="8.5.4 字符输出流Writer"></a>8.5.4 字符输出流Writer</h2><ol>
<li><p>Writer：所有的输出字符流的父类，它是一个抽象类。</p>
</li>
<li><p>CharArrayWriter、StringWriter：两种基本的介质流，它们分别向Char 数组、String 中写入数据。PipedWriter 是向与其它线程共用的管道中写入数据，</p>
</li>
<li><p>BufferedWriter: 一个装饰器为Writer 提供缓冲功能。</p>
</li>
<li><p>PrintWriter 和PrintStream 极其类似，功能和使用也非常相似。</p>
</li>
<li><p>OutputStreamWriter 是OutputStream 到Writer 转换的桥梁，它的子类FileWriter 其实就是这么一个实现此功能的类。功能和使用和OutputStream类似。</p>
</li>
</ol>
<h2 id="8-6-Java-IO流方法"><a href="#8-6-Java-IO流方法" class="headerlink" title="8.6 Java IO流方法"></a>8.6 Java IO流方法</h2><h2 id="8-6-1-字节流方法"><a href="#8-6-1-字节流方法" class="headerlink" title="8.6.1 字节流方法"></a>8.6.1 字节流方法</h2><p>字节输入流InputStream主要方法:</p>
<p>read() : 从此输入流中读取一个数据字节。</p>
<p>read(byte[] b) : 从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。</p>
<p>read(byte[] b, int off, int len) : 从此输入流中将最多 len 个字节的数据读入一个 byte 数组中。</p>
<p>close(): 关闭此输入流并释放与该流关联的所有系统资源。</p>
<p>字节输出流OutputStream主要方法:</p>
<p>write(byte[] b) : 将 b.length 个字节从指定 byte 数组写入此文件输出流中。</p>
<p>write(byte[] b, int off, int len) : 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流。</p>
<p>write(int b) : 将指定字节写入此文件输出流。</p>
<p>close() : 关闭此输入流并释放与该流关联的所有系统资源。</p>
<h2 id="8-6-2-字符流方法"><a href="#8-6-2-字符流方法" class="headerlink" title="8.6.2 字符流方法"></a>8.6.2 字符流方法</h2><p>字符输入流Reader主要方法:</p>
<p>read(): 读取单个字符。</p>
<p>read(char[] cbuf) : 将字符读入数组。</p>
<p>read(char[] cbuf, int off, int len) : 将字符读入数组的某一部分。</p>
<p>read(CharBuffer target) : 试图将字符读入指定的字符缓冲区。</p>
<p>flush() : 刷新该流的缓冲。</p>
<p>close() : 关闭此流，但要先刷新它。</p>
<p>字符输出流Writer主要方法:</p>
<p>write(char[] cbuf) ：写入字符数组。</p>
<p>write(char[] cbuf, int off, int len) : 写入字符数组的某一部分。</p>
<p>write(int c) : 写入单个字符。</p>
<p>write(String str) : 写入字符串。</p>
<p>write(String str, int off, int len) : 写入字符串的某一部分。</p>
<p>flush() : 刷新该流的缓冲。</p>
<p>close() ：关闭此流，但要先刷新它。</p>
<p>BufferedWriter类newLine() : 写入一个行分隔符。这个方法会自动适配所在系统的行分隔符。</p>
<p>BufferedReader类readLine() : 读取一个文本行。</p>
<h2 id="8-7-字节流与字符流的转换"><a href="#8-7-字节流与字符流的转换" class="headerlink" title="8.7 字节流与字符流的转换"></a>8.7 字节流与字符流的转换</h2><p>字节流与字符流的转换主要用于文本文件在硬盘中以字节流的形式存储时，通过InputStreamReader读取后转化为字符流给程序处理，程序处理的字符流通过OutputStreamWriter转换为字节流保存。</p>
<p>转换流有哪些基本特点呢?</p>
<ol>
<li><p>是字符流和字节流之间的桥梁</p>
</li>
<li><p>可对读取到的字节数据经过指定编码转换成字符</p>
</li>
<li><p>可对读取到的字符数据经过指定编码转换成字节</p>
</li>
</ol>
<p>那么什么时候使用转换流呢?</p>
<ol>
<li><p>当字节和字符之间有转换动作</p>
</li>
<li><p>流操作的数据需要编码或解码</p>
</li>
</ol>
<p>具体的对象体现在哪些方面?</p>
<ol>
<li><p>InputStreamReader:字节到字符的桥梁</p>
</li>
<li><p>OutputStreamwriter:字符到字节的桥梁</p>
</li>
</ol>
<p>这两个流对象是字符体系中的成员，它们有转换作用，本身又是字符流，所以在构造的时候需要传入字节流对象进来。</p>
<ol>
<li><p>Outputstreamwriter(Outstreamout) :将字节流以字符流输出。</p>
</li>
<li><p>InputstreamReader(Inputstream in): 将字节流以字符流输入。</p>
</li>
</ol>
<p>public class IOTest {</p>
<p>public static void write(File file) throws IOException {</p>
<p>&#x2F;&#x2F; OutputStreamwriter可以显示指定字符集, 否则使用默认字符集</p>
<p>OutputStreamwriter osw &#x3D; new OutputStreamWriter(new</p>
<p>FileOutputStream(file, true), “UTF-8”);</p>
<p>&#x2F;&#x2F; 要写入的字符串</p>
<p>string string ( &#x3D; ) “松下问童子,言师采药去。只在此山中,云深不知处。”;</p>
<p>osw.write(string);</p>
<p>osw.close();</p>
<p>}</p>
<p>public static String read(File file) throws IOException {</p>
<p>InputStreamReader isr &#x3D; new InputStreamReader(new FileInputStream(file),</p>
<p>“UTF-8”);</p>
<p>&#x2F;&#x2F; 字符数组: 一次读取多少个字符</p>
<p>char[] chars ( &#x3D; ) new char[1024];</p>
<p>&#x2F;&#x2F; 每次读取的字符数组先append到StringBuilder中</p>
<p>StringBuilder ( \mathrm &#x3D; ) new StringBuilder();</p>
<p>&#x2F;&#x2F; 读取到的字符数组长度, 为-1时表示没有数据</p>
<p>int length;</p>
<p>&#x2F;&#x2F; 循环取数据</p>
<p>while ((length &#x3D; isr.read(chars)) !&#x3D; -1) {</p>
<p>&#x2F;&#x2F; 将读取的内容转换成字符串</p>
<p>sb.append(chars, 0, length);</p>
<p>}</p>
<p>&#x2F;&#x2F; 关闭流</p>
<p>isr.close();</p>
<p>return sb.toString()</p>
<p>}</p>
<h2 id="8-8-字节流与字符流的区别"><a href="#8-8-字节流与字符流的区别" class="headerlink" title="8.8 字节流与字符流的区别"></a>8.8 字节流与字符流的区别</h2><ol>
<li><p>读写的单位有所不同：字节流以字节 (8bit) 为单位，字符流以字符为单位，根据码表映射字符， 一次可能读多个字节。</p>
</li>
<li><p>处理的对象有所不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</p>
</li>
<li><p>字节流没有缓冲区，是直接输出的，而字符流是输出到缓冲区的。因此在输出时，字节流不调用 colse()方法时，信息已经输出了，而字符流只有在调用close()方法关闭缓冲区时，信息才输出。要想字符流在未关闭时输出信息，则需要手动调用flush()方法。</p>
</li>
</ol>
<h2 id="8-9-小结"><a href="#8-9-小结" class="headerlink" title="8.9 小结"></a>8.9 小结</h2><p>想要更系统的学习java IO系统，除了掌握这些基础的IO知识以外，重点是要学会IO模型，了解了各种IO 模型之后才可以更好的理解java IO，所以大家在看了这篇文章之后还需要再去深入学习一些关于IO模型的知识与运用哦~</p>
<h1 id="9-Java-注解详解"><a href="#9-Java-注解详解" class="headerlink" title="9. Java 注解详解"></a>9. Java 注解详解</h1><p>注解，英文名Annotation。官方文档中对注解的定义是这样的：Java注解用于为Java代码提供元数据。 作为元数据，注解不直接影响你的代码运行，但是也有一些类型的注解实际上可以用于这些目的。</p>
<p>Java注解是从 Java5 开始添加到 Java 里面的。看完这句话你可能对注解的定义还是一头雾水，接下来就和我一起结合案例来深入学习Java注解相关的知识吧。</p>
<h2 id="9-1-什么是注解"><a href="#9-1-什么是注解" class="headerlink" title="9.1 什么是注解?"></a>9.1 什么是注解?</h2><p>日常开发中新建 Java 类，比较常见的有 class、interface 等，而注解同样也属于一种类，只不过它的修饰符是 ‘@interface’。</p>
<p>public interface override extends Annotation {</p>
<p>一个注解准确意义上来说，只不过是一种特殊的注释而已，如果没有解析它的代码，它可能连注释都不是。</p>
<h2 id="9-2-元注解探秘"><a href="#9-2-元注解探秘" class="headerlink" title="9.2 元注解探秘"></a>9.2 元注解探秘</h2><p>元注解是用于修饰注解的注解，通常用在注解的定义上。</p>
<p>Java 中元注解有以下几种形式:</p>
<ul>
<li><p>@Target: 注解的作用目标</p>
</li>
<li><p>@Inherited: 是否允许子类继承该注解</p>
</li>
<li><p>@Retention: 注解的生命周期</p>
</li>
<li><p>@Documented: 注解是否应当被包含在 JavaDoc 文档中</p>
</li>
<li><p>@Repeatable：说明被这个元注解修饰的注解可以同时作用一个对象多次，每次作用注解代表不同的含义</p>
</li>
</ul>
<h2 id="9-2-1-Target"><a href="#9-2-1-Target" class="headerlink" title="9.2.1 Target"></a>9.2.1 Target</h2><ul>
<li><p>@Target元注解表示我们的注解作用的范围就很大，有类，方法，方法参数变量等，还可通过枚举类ElementType来表示作用类型。</p>
</li>
<li><p>@Target(ElementType.TYPE) 作用接口、类、枚举、注解。</p>
</li>
<li><p>@Target(ElementType.FIELD) 作用属性字段、枚举的常量。</p>
</li>
<li><p>@Target(ElementType.METHOD) 作用方法。</p>
</li>
<li><p>@Target(ElementType.PARAMETER) 作用方法参数。</p>
</li>
<li><p>@Target(ElementType.CONSTRUCTOR) 作用构造函数。</p>
</li>
<li><p>@Target(ElementType.LOCAL_VARIABLE) 作用局部变量。</p>
</li>
<li><p>@Target(ElementType.ANNOTATION_TYPE) 作用于注解 (@Retention注解中就使用该属性）。</p>
</li>
<li><p>@Target(ElementType.PACKAGE) 作用于包。</p>
</li>
<li><p>@Target(ElementType.TYPE_PARAMETER) 作用于类型泛型，即泛型方法、泛型类、泛型接口 （jdk1.8加入）。</p>
</li>
<li><p>( @ ) Target(ElementType.TYPE_USE) 类型使用.可以用于标注任意类型除了 class (jdk1.8加入) - 般比较常用的是ElementType.TYPE类型。</p>
</li>
</ul>
<p>PS：@Target 用于指明被修饰的注解最终可以作用的目标是谁，也就是指明，你的注解到底是用来修饰方法、修饰类亦或者是用来修饰字段属性的。</p>
<h2 id="9-2-2-Inherited"><a href="#9-2-2-Inherited" class="headerlink" title="9.2.2 @Inherited"></a>9.2.2 @Inherited</h2><ul>
<li>Inherited 的意思是继承，但是这个继承和我们平时理解的继承大同小异，一个被 @Inherited 注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解。</li>
</ul>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="&#x2F;*自定义注解&#x2F;"></a>&#x2F;*<em>自定义注解</em>&#x2F;</h2><p>@Documented</p>
<p>@Inherited</p>
<p>@Retention(RetentionPolicy.RUNTIME)</p>
<p>@Target(ElementType.TYPE)</p>
<p>public @interface MyTestAnnotation {</p>
<p>}</p>
<p>&#x2F;*<em>父类标注自定义注解</em>&#x2F;</p>
<p>@MyTestAnnotation</p>
<p>public class Father {</p>
<p>}</p>
<p>&#x2F;*<em>子类</em>&#x2F;</p>
<p>public class Son extends Father {</p>
<p>}</p>
<p>&#x2F;*<em>测试子类获取父类自定义注解</em>&#x2F;</p>
<p>public class test {</p>
<p>public static void main(String[] args){</p>
<p>&#x2F;&#x2F;获取Son的class对象</p>
<p>Class<Son> sonClass &#x3D; Son.class;</p>
<p>&#x2F;&#x2F; 获取Son类上的注解MyTestAnnotation可以执行成功</p>
<p>MyTestAnnotation annotation ( &#x3D; )</p>
<p>sonClass.getAnnotation(MyTestAnnotation.class);</p>
<p>}</p>
<p>}</p>
<h2 id="9-2-3-Retention"><a href="#9-2-3-Retention" class="headerlink" title="9.2.3 @Retention"></a>9.2.3 @Retention</h2><ul>
<li><p>Retention有保留、保持的意思，它表示注解存在阶段是保留在源码（编译期），字节码（类加载） 或者运行期（JVM中运行）。在@Retention注解中使用枚举RetentionPolicy来表示注解保留时期。</p>
</li>
<li><p>@Retention(RetentionPolicy.CLASS)，默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得。</p>
</li>
<li><p>@Retention(RetentionPolicy.SOURCE)，注解仅存在于源码中，在class字节码文件中并不包含。</p>
</li>
<li><p>@Retention(RetentionPolicy.RUNTIME)，注解会在class字节码文件中存在，在运行时可以通过反射获取到。</p>
</li>
<li><p>如果我们是自定义注解，则通过前面分析，我们自定义注解如果只存着源码中或者字节码文件中就无法发挥作用，而在运行期间能获取到注解才能实现我们目的，所以自定义注解中肯定是使用 @Retention(RetentionPolicy.RUNTIME)。</p>
</li>
</ul>
<h2 id="9-2-4-Documented"><a href="#9-2-4-Documented" class="headerlink" title="9.2.4 @Documented"></a>9.2.4 @Documented</h2><ul>
<li>Document的英文意思是文档。它的作用是能够将注解中的元素包含到 Javadoc 中去。</li>
</ul>
<h2 id="9-2-5-Repeatable"><a href="#9-2-5-Repeatable" class="headerlink" title="9.2.5 @Repeatable"></a>9.2.5 @Repeatable</h2><ul>
<li>Repeatable表示可重复的。从字面意思来理解就是说明被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。</li>
</ul>
<hr>
<p>&#x2F;*<em>小Y喜欢玩游戏, 他喜欢玩英雄联盟, 绝地求生, 极品飞车, 尘埃4等, 则我们需要定义一个人的注解, 他属性代表喜欢玩游戏集合, 一个游戏注解, 游戏属性代表游戏名称</em>&#x2F;</p>
<p>&#x2F;*<em>玩家注解</em>&#x2F;</p>
<p>@Documented</p>
<p>@Retention(RetentionPolicy.RUNTIME)</p>
<p>@Target(ElementType.TYPE)</p>
<p>public @interface People {</p>
<p>Game[] value() ;</p>
<p>}</p>
<p>&#x2F;*<em>游戏注解</em>&#x2F;</p>
<hr>
<p>@Repeatable(People.class)</p>
<p>@Retention(RetentionPolicy.RUNTIME)</p>
<p>@Target(ElementType.TYPE)</p>
<p>public @interface Game {</p>
<p>String value() default “”;</p>
<p>}</p>
<p>&#x2F;*<em>玩游戏类</em>&#x2F;</p>
<p>@Game(value &#x3D; “LOL”)</p>
<p>@Game(value &#x3D; “PUBG”)</p>
<p>@Game(value &#x3D; “NFS”)</p>
<p>@Game(value &#x3D; “Dirt4”)</p>
<p>public class PlayGame {</p>
<p>}</p>
<h2 id="9-3-注解属性知多少"><a href="#9-3-注解属性知多少" class="headerlink" title="9.3 注解属性知多少"></a>9.3 注解属性知多少</h2><p>注解的属性其实和类中定义的变量有异曲同工之处，只是注解中的变量都是成员变量（属性），并且注解中是没有方法的，只有成员变量，变量名就是使用注解括号中对应的参数名，变量返回值注解括号中对应参数类型。相信这会你应该会对上面的例子有一个更深的认识。而 ( @ ) Repeatable 注解中的变量则类型则是对应 Annotation (接口) 的泛型 Class。</p>
<p>&#x2F;*<em>注解Repeatable源码</em>&#x2F;</p>
<p>@Documented</p>
<p>@Retention(RetentionPolicy.RUNTIME)</p>
<p>@Target(ElementType.ANNOTATION_TYPE)</p>
<p>public @interface Repeatable {</p>
<p>&#x2F;**</p>
<ul>
<li><p>Indicates the <em>containing annotation type</em> for the</p>
</li>
<li><p>repeatable annotation type.</p>
</li>
<li><p>@return the containing annotation type</p>
</li>
</ul>
<p>*&#x2F;</p>
<p>Class&lt;? extends Annotation&gt; value();</p>
<p>}</p>
<h1 id="9-自定义注解"><a href="#9-自定义注解" class="headerlink" title="9. 自定义注解"></a>9. 自定义注解</h1><h2 id="9-4-1-注解的本质"><a href="#9-4-1-注解的本质" class="headerlink" title="9.4.1 注解的本质"></a>9.4.1 注解的本质</h2><p>注解的本质就是一个Annotation接口。</p>
<p>&#x2F;*<em>Annotation接口源码</em>&#x2F;</p>
<p>public interface Annotation {</p>
<p>boolean equals(Object obj);</p>
<p>int hashCode();</p>
<p>Class&lt;? extends Annotation&gt; annotationType();</p>
<p>}</p>
<p>从上述代码中我们可以看出，注解本身就是Annotation接口的子接口，也就是说注解中其实是可以有属性和方法，但是接口中的属性都是static final的，对于注解来说没什么意义，而我们定义接口的方法就相当于注解的属性，也就对应了前面说的为什么注解只有属性成员变量，其实他就是接口的方法，这就是为什么成员变量会有括号，不同于接口我们可以在注解的括号中给成员变量赋值。</p>
<h2 id="9-4-2-注解属性类型"><a href="#9-4-2-注解属性类型" class="headerlink" title="9.4.2 注解属性类型"></a>9.4.2 注解属性类型</h2><ul>
<li><p>基本数据类型</p>
</li>
<li><p>String</p>
</li>
<li><p>枚举类型</p>
</li>
<li><p>注解类型</p>
</li>
<li><p>Class类型</p>
</li>
<li><p>以上类型的一维数组类型</p>
</li>
</ul>
<h2 id="9-4-3-为注解成员变量赋值"><a href="#9-4-3-为注解成员变量赋值" class="headerlink" title="9.4.3 为注解成员变量赋值"></a>9.4.3 为注解成员变量赋值</h2><p>如果注解又多个属性，则可以在注解括号中用“，”号隔开分别给对应的属性赋值，如下例子，注解在父类中赋值属性。</p>
<p>@Documented</p>
<p>@Inherited</p>
<p>@Retention(RetentionPolicy.RUNTIME)</p>
<p>@Target(ElementType.TYPE)</p>
<p>public @interface MyTestAnnotation {</p>
<p>String name() default “mao”;</p>
<p>int age() default 18;</p>
<p>}</p>
<p>@MyTestAnnotation(name &#x3D; “father”, age &#x3D; 50)</p>
<p>public class Father {</p>
<p>}</p>
<h2 id="9-4-4-获取注解的属性"><a href="#9-4-4-获取注解的属性" class="headerlink" title="9.4.4 获取注解的属性"></a>9.4.4 获取注解的属性</h2><p>前面我们说了很多注解如何定义，放在哪，现在我们可以开始学习注解属性的提取了，这才是使用注解的关键，获取属性的值才是使用注解的目的。如果获取注解属性，当然是反射啦，主要有三个基本的方法:</p>
<p>&#x2F;*<em>是否存在对应 Annotation 对象</em>&#x2F;</p>
<p>public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</p>
<p>{</p>
<p>return GenericDeclaration.super.isAnnotationPresent(annotationClass);</p>
<p>}</p>
<p>&#x2F;*<em>获取 Annotation 对象</em>&#x2F;</p>
<p>public <A extends Annotation> A getAnnotation(Class<A> annotationClass) {</p>
<p>Objects.requireNonNull(annotationClass);</p>
<p>return (A) annotationData().annotations.get(annotationClass);</p>
<p>}</p>
<p>&#x2F;*<em>获取所有 Annotation 对象数组</em>&#x2F;</p>
<p>public Annotation[] getAnnotations() { return AnnotationParser.toArray(annotationData().annotations);</p>
<p>下面结合前面的例子，我们来获取一下注解属性，在获取之前我们自定义的注解必须使用元注解 @Retention(RetentionPolicy.RUNTIME)。</p>
<p>public class test {</p>
<p>public static void main(String[] args) throws NoSuchMethodException {</p>
<p>&#x2F;**</p>
<ul>
<li>获取类注解属性</li>
</ul>
<p>*&#x2F;</p>
<p>Class<Father> fatherClass &#x3D; Father.class;</p>
<p>boolean annotationPresent ( &#x3D; )</p>
<p>fatherClass. isAnnotationPresent(MyTestAnnotation.class);</p>
<p>if(annotationPresent){</p>
<p>MyTestAnnotation annotation ( &#x3D; )</p>
<p>fatherClass.getAnnotation(MyTestAnnotation.class);</p>
<p>System.out.println(annotation.name());</p>
<p>System.out.println(annotation.age());</p>
<p>}</p>
<p>&#x2F;**</p>
<ul>
<li>获取方法注解属性</li>
</ul>
<p>*&#x2F;</p>
<p>try ( { )</p>
<p>Field age &#x3D; fatherClass.getDeclaredField(“age”);</p>
<p>boolean annotationPresent1 &#x3D; age.isAnnotationPresent(Age.class);</p>
<p>if(annotationPresent1){</p>
<p>Age annotation ( &#x3D; ) age.getAnnotation(Age.class);</p>
<p>System.out.println(annotation.value());</p>
<p>}</p>
<p>Method play ( &#x3D; ) PlayGame.class.getDeclaredMethod(“play”);</p>
<p>if (play!&#x3D;null){</p>
<p>People annotation2 &#x3D; play.getAnnotation(People.class);</p>
<p>Game[] value ( &#x3D; ) annotation2.value();</p>
<p>for (Game game : value) {</p>
<p>System.out.println(game.value());</p>
<p>}</p>
<p>}</p>
<p>} catch (NoSuchFieldException e) {</p>
<p>e.printstackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<h2 id="9-5-JDK提供的注解"><a href="#9-5-JDK提供的注解" class="headerlink" title="9.5 JDK提供的注解"></a>9.5 JDK提供的注解</h2><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tr><td>@SuppressWarnings</td><td>对程序中的警告去除。</td></tr><tr><td>@Deprecated</td><td>它是用于描述当前方法是一个过时的方法。</td></tr></table>



<table><thead><tr><th>注解</th><th>作用</th></tr></thead><tr><td>@Override</td><td>主要是用来描述当前方法是一个重写的方法，在编译阶段对方法进行检 查。jdk1.5中它只能描述继承中的重写，jdk1.6中它可以描述接口实现的 重写,也能描述类的继承的重写。</td></tr></table>

<h2 id="9-6-注解的运用"><a href="#9-6-注解的运用" class="headerlink" title="9.6 注解的运用"></a>9.6 注解的运用</h2><p>如果你是一名Android 开发者，平常所使用的第三方框架ButterKnife，Retrofit2，Dagger2等都有注解的应用，如果想要了解这些框架的原理，则注解的基础知识则是必不可少的。</p>
<h2 id="9-7-注解的意义"><a href="#9-7-注解的意义" class="headerlink" title="9.7 注解的意义"></a>9.7 注解的意义</h2><ul>
<li><p>提供信息给编译器： 编译器可以利用注解来检测出错误或者警告信息，打印出日志。</p>
</li>
<li><p>编译阶段时的处理： 软件工具可以用来利用注解信息来自动生成代码、文档或者做其它相应的自动处理。</p>
</li>
<li><p>运行时处理：某些注解可以在程序运行的时候接受代码的提取，自动做相应的操作。</p>
</li>
</ul>
<ul>
<li>正如官方文档的那句话所说，注解能够提供元数据，转账例子中处理获取注解值的过程是我们开发者直接写的注解提取逻辑，处理提取和处理 Annotation 的代码统称为 APT (Annotation</li>
</ul>
<p>Processing Tool)。上面转账例子中的processAnnotationMoney方法就可以理解为APT工具类。</p>
<p>更多关于注解的有意思的学习经历也需要靠大家在日常工作中认真去体会啦！</p>
<h1 id="10-Java-泛型"><a href="#10-Java-泛型" class="headerlink" title="10. Java 泛型"></a>10. Java 泛型</h1><h2 id="10-1-泛型的提出？"><a href="#10-1-泛型的提出？" class="headerlink" title="10.1 泛型的提出？"></a>10.1 泛型的提出？</h2><ul>
<li>泛型实质上就是是程序员定义安全的类型。在没有出现泛型之前，Java提供了对Object的引用“任意化“操作，这种“任意化”操作就是对Object引用进行向下转型及向上转型操作，但某些强制类型转换的错误也许不会被编译器捕捉，而在运行后出现异常，可吉安强制类型转换存在安全隐患，所以在此提供了泛型机制。</li>
</ul>
<ul>
<li>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</li>
</ul>
<p>说再多不如举了例子来帮助大家理解:</p>
<p>List arrayList ( &#x3D; ) new ArrayList();</p>
<p>arrayList.add(“aaaa”);</p>
<p>arrayList.add(100);</p>
<p>for(int ( i &#x3D; 0 ) ; ( i &lt; \operatorname{arrayList.size();}i + + ){ )</p>
<p>String item ( &#x3D; ) (String)arrayList.get(i);</p>
<p>Log. ( d ) (“泛型测试”,”item ( &#x3D; ) “ + item);</p>
<p>}</p>
<p>这样的代码运行的最终结果必然是会崩溃的:</p>
<p>java.lang.classCastException: java.lang.Integer cannot be cast to</p>
<p>java.lang.string</p>
<p>ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以 String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</p>
<p>我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。</p>
<p>List<String> arrayList &#x3D; new ArrayList<String>();</p>
<p>( \cdots )</p>
<p>&#x2F;&#x2F;arrayList.add(100); 在编译阶段, 编译器就会报错</p>
<p>那么有没有什么办法可以使集合能够记住集合内元素各类型，且能够达到只要编译时不出现问题，运行时就不会出现“java.lang.ClassCastException”异常呢？答案就是使用泛型。</p>
<h2 id="10-2-常用的泛型类型变量"><a href="#10-2-常用的泛型类型变量" class="headerlink" title="10.2 常用的泛型类型变量"></a>10.2 常用的泛型类型变量</h2><p>E: 元素 (Element) ，多用于java集合框架。</p>
<p>K：关键字（Key）。</p>
<p>N: 数字 (Number) 。</p>
<p>T：类型（Type）。</p>
<p>V：值（Value）。</p>
<h2 id="10-3-泛型的使用"><a href="#10-3-泛型的使用" class="headerlink" title="10.3 泛型的使用"></a>10.3 泛型的使用</h2><p>泛型有三种使用方式，分别为:</p>
<ul>
<li><p>泛型类</p>
</li>
<li><p>泛型接口</p>
</li>
<li><p>泛型方法</p>
</li>
</ul>
<h2 id="1-0-3-1-泛型类"><a href="#1-0-3-1-泛型类" class="headerlink" title="1.0.3.1 泛型类"></a>1.0.3.1 泛型类</h2><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p>
<p>定义一个泛型类:</p>
<p>class 类名称 ( &lt; ) 泛型标识: 可以随便写任意标识号,标识指定的泛型的类型 ( &gt; { )</p>
<p>private 泛型标识 &#x2F;* (成员变量类型) *&#x2F; var;</p>
<p>( \cdots )</p>
<p>}</p>
<p>}</p>
<h2 id="将案例具体化"><a href="#将案例具体化" class="headerlink" title="将案例具体化:"></a>将案例具体化:</h2><p>public class Generic<T>{</p>
<p>&#x2F;&#x2F;key这个成员变量的类型为 ( T, T ) 的类型由外部指定</p>
<p>private ( T ) key;</p>
<p>public Generic(T key) { &#x2F;&#x2F;泛型构造方法形参key的类型也为T, T的类型由外部指定 this.key ( &#x3D; ) key; }</p>
<p>public T getKey() { &#x2F;&#x2F;泛型方法getKey的返回值类型为T, T的类型由外部指定</p>
<p>return key;</p>
<p>}</p>
<p>}</p>
<p>&#x2F;&#x2F;泛型的类型参数只能是类类型 (包括自定义类), 不能是简单类型</p>
<p>&#x2F;&#x2F;传入的实参类型需与泛型的类型参数类型相同, 即为Integer.</p>
<p>Generic<Integer> genericInteger &#x3D; new Generic<Integer>(123456);</p>
<p>&#x2F;&#x2F;传入的实参类型需与泛型的类型参数类型相同, 即为String.</p>
<p>Generic<String> genericString &#x3D; new Generic<String>(“key_vlaue”);</p>
<p>Log.d(“泛型测试”,”key is “ + genericInteger.getKey());</p>
<p>Log.d(“泛型测试”,”key is “ + genericString.getKey());</p>
<p>测试结果:</p>
<p>12-27 09:20:04.432 13063-13063&#x2F;? D&#x2F;泛型测试: key is 123456</p>
<p>12-27 09:20:04.432 13063-13063&#x2F;? D&#x2F;泛型测试: key is key_vlaue</p>
<p>定义的泛型类并不是一定要传入泛型类型实参。在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p>
<p>再举一个例子:</p>
<p>Generic generic &#x3D; new Generic(“111111”);</p>
<p>Generic generic1 &#x3D; new Generic(4444);</p>
<p>Generic generic2 &#x3D; new Generic(55.55);</p>
<p>Generic generic3 &#x3D; new Generic(false);</p>
<p>Log.d(“泛型测试”,”key is “ + generic.getKey());</p>
<p>Log.d(“泛型测试”,”key is “ + generic1.getKey());</p>
<p>Log.d(“泛型测试”,”key is “ + generic2.getKey());</p>
<p>Log.d(“泛型测试”,”key is “ + generic3.getKey());</p>
<p>运行结果:</p>
<p>D&#x2F;泛型测试: key is 111111</p>
<p>D&#x2F;泛型测试：key is 4444</p>
<p>D&#x2F;泛型测试: key is ( {55.55} )</p>
<p>D&#x2F;泛型测试: key is false</p>
<h2 id="值得注意的是"><a href="#值得注意的是" class="headerlink" title="值得注意的是:"></a>值得注意的是:</h2><ol>
<li><p>泛型的类型参数只能是类类型，不能是简单类型。</p>
</li>
<li><p>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。</p>
</li>
</ol>
<p>if(ex_num instanceof Generic<Number>){ }</p>
<h2 id="10-3-2-泛型接口"><a href="#10-3-2-泛型接口" class="headerlink" title="10.3.2 泛型接口"></a>10.3.2 泛型接口</h2><p>定义一个泛型接口: public interface GenericIntercace{}</p>
<p>public interface GenericIntercace<T> {</p>
<p>T getData();</p>
<p>}</p>
<p>实现泛型接口方式一：public class ImplGenericInterface1 implements GenericIntercace</p>
<hr>
<p>public class ImplGenericInterface1<T> implements GenericIntercace<T> {</p>
<p>private ( T ) data;</p>
<p>private void setData(T data) {</p>
<p>this.data ( &#x3D; ) data;</p>
<p>}</p>
<p>@override</p>
<p>public T getData() {</p>
<p>return data;</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>ImplGenericInterface1<String> implGenericInterface1 &#x3D; new</p>
<p>ImplGenericInterface1&lt;&gt;();</p>
<p>implGenericInterface1.setData(“Generic Interface1”);</p>
<p>System.out.println(implGenericInterface1.getData());</p>
<p>}</p>
<p>}</p>
<hr>
<p>实现泛型接口方式二：public class ImplGenericInterface2 implements GenericIntercace {}</p>
<p>public class ImplGenericInterface2 implements GenericIntercace<String> {</p>
<p>@override</p>
<p>public String getData() {</p>
<p>return “Generic Interface2”;</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>ImplGenericInterface2 implGenericInterface2 &#x3D; new</p>
<p>ImplGenericInterface2();</p>
<p>System.out.println(implGenericInterface2.getData());</p>
<p>}</p>
<p>}</p>
<h2 id="10-3-3-泛型方法"><a href="#10-3-3-泛型方法" class="headerlink" title="10.3.3 泛型方法"></a>10.3.3 泛型方法</h2><p>泛型方法是在调用方法的时候指明泛型的具体类型。</p>
<p>&#x2F;**</p>
<ul>
<li><p>泛型方法的基本介绍</p>
</li>
<li><p>@param tclass 传入的泛型实参</p>
</li>
<li><p>@return T 返回值为T类型</p>
</li>
<li><p>说明:</p>
</li>
</ul>
<ol>
<li>public 与 返回值中间<T>非常重要, 可以理解为声明此方法为泛型方法。</li>
</ol>
<p>2）只有声明了<T>的方法才是泛型方法, 泛型类中的使用了泛型的成员方法并不是泛型方法。</p>
<p>3） ( &lt; \mathrm{T} &gt; ) 表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</p>
<ol start="4">
<li>与泛型类的定义一样,此处T可以随便写为任意标识,常见的如T、E、K、V等形式的参数常用于表</li>
</ol>
<p>示泛型。</p>
<p>*&#x2F;</p>
<p>public ( &lt; T &gt; T ) genericMethod(Class ( &lt; T &gt; ) tclass)throws InstantiationException,</p>
<p>IllegalAccessException{</p>
<p>T instance ( &#x3D; ) tclass.newInstance();</p>
<p>return instance;</p>
<p>}</p>
<p>object obj &#x3D; genericMethod(Class.forName(“com.test.test”));</p>
<h2 id="10-3-3-1-泛型方法的基本用法"><a href="#10-3-3-1-泛型方法的基本用法" class="headerlink" title="10.3.3.1 泛型方法的基本用法"></a>10.3.3.1 泛型方法的基本用法</h2><p>public class GenericTest {</p>
<p>&#x2F;&#x2F;这个类是个泛型类, 在上面已经介绍过</p>
<p>public class Generic<T>{</p>
<p>private ( T ) key;</p>
<p>public Generic(T key) {</p>
<p>this.key ( &#x3D; ) key;</p>
<p>}</p>
<p>&#x2F;&#x2F;我想说的其实是这个, 虽然在方法中使用了泛型, 但是这并不是一个泛型方法。</p>
<p>&#x2F;&#x2F;这只是类中一个普通的成员方法, 只不过他的返回值是在声明泛型类已经声明过的泛型。</p>
<p>&#x2F;&#x2F;所以在这个方法中才可以继续使用 ( \mathrm{T} ) 这个泛型。</p>
<p>public T getKey(){</p>
<p>return key;</p>
<p>}</p>
<p>&#x2F;**</p>
<ul>
<li><p>这个方法显然是有问题的, 在编译器会给我们提示这样的错误信息”cannot reslove symbol</p>
</li>
<li><p>因为在类的声明中并未声明泛型E,所以在使用E做形参和返回值类型时,编译器会无法识别。</p>
</li>
</ul>
<p>public ( E ) setKey(E ( {key}){ )</p>
<p>this.key ( &#x3D; ) keu</p>
<p>}</p>
<p>*&#x2F;</p>
<p>&#x2F;**</p>
<ul>
<li>这才是一个真正的泛型方法。</li>
</ul>
<p>首先在public与返回值之间的<T>必不可少, 这表明这是一个泛型方法, 并且声明了一个泛型T</p>
<ul>
<li>这个T可以出现在这个泛型方法的任意位置.</li>
</ul>
<p>’泛型的数量也可以为任意多个</p>
<p>如: public &lt;T, K&gt; K showKeyName(Generic<T> container){</p>
<ul>
<li>. .</li>
</ul>
<p>}</p>
<p>*&#x2F;</p>
<p>public <T> T showKeyName(Generic<T> container){</p>
<p>System.out.println(“container key :” + container.getKey());</p>
<p>&#x2F;&#x2F;当然这个例子举的不太合适, 只是为了说明泛型方法的特性。</p>
<p>( T ) test ( &#x3D; ) container.getKey();</p>
<p>return test;</p>
<p>}</p>
<p>&#x2F;&#x2F;这也不是一个泛型方法, 这就是一个普通的方法, 只是使用了Generic<Number>这个泛型类做形参而已。</p>
<p>public void showKeyValue1(Generic<Number> obj){</p>
<p>Log.d(“泛型测试”,”key value is “ + obj.getKey());</p>
<p>}</p>
<p>&#x2F;&#x2F;这也不是一个泛型方法, 这也是一个普通的方法, 只不过使用了泛型通配符?</p>
<p>&#x2F;&#x2F;同时这也印证了泛型通配符章节所描述的, ?是一种类型实参, 可以看做为Number等所有类的父类</p>
<p>public void showKeyValue2(Generic&lt;?&gt; obj){</p>
<p>Log.d(“泛型测试”,”key value is “ + obj.getKey());</p>
<p>}</p>
<p>&#x2F;**</p>
<ul>
<li><p>这个方法是有问题的,编译器会为我们提示错误信息: “UnKnown class ‘E’ “</p>
</li>
<li><p>虽然我们声明了 ( &lt; \mathrm{T} &gt; ) ,也表明了这是一个可以处理泛型的类型的泛型方法。</p>
</li>
<li><p>但是只声明了泛型类型T,并未声明泛型类型E,因此编译器并不知道该如何处理E这个类型。</p>
</li>
</ul>
<p>public <T> T showKeyName(Generic<E> container){</p>
<p>( \cdots )</p>
<p>}</p>
<p>*&#x2F;</p>
<p>&#x2F;**</p>
<ul>
<li><p>这个方法也是有问题的,编译器会为我们提示错误信息: “Unknown class ‘T’ “</p>
</li>
<li><p>对于编译器来说T这个类型并未项目中声明过, 因此编译也不知道该如何编译这个类。</p>
</li>
<li><p>所以这也不是一个正确的泛型方法声明。</p>
</li>
</ul>
<p>public void showkey(T genericobj){</p>
<p>}</p>
<p>*&#x2F;</p>
<p>public static void main(String[] args) {</p>
<p>} }</p>
<h2 id="10-3-3-2-类中的泛型方法"><a href="#10-3-3-2-类中的泛型方法" class="headerlink" title="10.3.3.2 类中的泛型方法"></a>10.3.3.2 类中的泛型方法</h2><p>当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下</p>
<hr>
<p>public class GenericFruit {</p>
<p>class Fruit{</p>
<p>@override</p>
<p>public string toString() {</p>
<p>return “fruit”;</p>
<p>}</p>
<p>}</p>
<p>class Apple extends Fruit{</p>
<p>@override</p>
<p>public string toString() {</p>
<p>return “apple”;</p>
<p>} }</p>
<hr>
<h2 id="10-3-3-3-静态方法与泛型"><a href="#10-3-3-3-静态方法与泛型" class="headerlink" title="10.3.3.3 静态方法与泛型"></a>10.3.3.3 静态方法与泛型</h2><hr>
<p>class Person{</p>
<p>@override</p>
<p>public string toString() {</p>
<p>return “Person”;</p>
<p>}</p>
<p>}</p>
<p>class GenerateTest<T>{</p>
<p>public void show_1(T t){</p>
<p>System.out.println(t.toString());</p>
<p>}</p>
<p>&#x2F;&#x2F;在泛型类中声明了一个泛型方法,使用泛型 ( \mathrm{E} ) ,这种泛型 ( \mathrm{E} ) 可以为任意类型。可以类型与 ( \mathrm{T} ) 相同,也可以不同。</p>
<p>&#x2F;&#x2F;由于泛型方法在声明的时候会声明泛型 ( &lt; \mathrm{E} &gt; ) ,因此即使在泛型类中并未声明泛型,编译器也能够正确识别泛型方法中识别的泛型。</p>
<p>public <E> void show_3(E t){</p>
<p>System.out.println(t.toString());</p>
<p>}</p>
<p>&#x2F;&#x2F;在泛型类中声明了一个泛型方法, 使用泛型T, 注意这个T是一种全新的类型, 可以与泛型类中声明的T不是同一种类型。</p>
<p>public <T> void show_2(T t){</p>
<p>System.out.println(t.toString());</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>Apple apple ( &#x3D; ) new Apple();</p>
<p>Person person ( &#x3D; ) new Person();</p>
<p>GenerateTest<Fruit> generateTest &#x3D; new GenerateTest<Fruit>();</p>
<p>&#x2F;&#x2F;apple是Fruit的子类, 所以这里可以</p>
<p>generateTest.show_1(apple);</p>
<p>&#x2F;&#x2F;编译器会报错, 因为泛型类型实参指定的是 Fruit, 而传入的实参类是 Person</p>
<p>&#x2F;&#x2F;generateTest.show_1(person);</p>
<p>&#x2F;&#x2F;使用这两个方法都可以成功</p>
<p>generateTest.show_2(apple);</p>
<p>generateTest.show_2(person);</p>
<p>&#x2F;&#x2F;使用这两个方法也都可以成功</p>
<p>generateTest.show_3(apple);</p>
<p>generateTest.show_3(person);</p>
<p>} }</p>
<p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</p>
<hr>
<p>即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法。</p>
<p>public class StaticGenerator<T> {</p>
<p>( \cdots )</p>
<p>… …</p>
<p>&#x2F;**</p>
<ul>
<li><p>如果在类中定义使用泛型的静态方法, 需要添加额外的泛型声明 (将这个方法定义成泛型方法)</p>
</li>
<li><p>即使静态方法要使用泛型类中已经声明过的泛型也不可以。</p>
</li>
<li><p>如: public static void show(T t){..},此时编译器会提示错误信息:</p>
</li>
</ul>
<p>“StaticGenerator cannot be refrenced from static context”</p>
<p>*&#x2F;</p>
<p>public static ( &lt; T &gt; ) void show(T t){</p>
<p>}</p>
<p>}</p>
<p>至此，我们可以发现，在使用泛型类时，虽然有不同的泛型实参传入，但并没有真正意义上生成不同的类型，不同泛型实参的泛型类传入内存并只有一个，即还是原来的最基本的类型，当然，在逻辑上我们可以理解成多个不同的泛型类型。</p>
<p>细想原因，在于Java中的泛型这一概念提出的目的，导致其只是作用于代码编译阶段，在编译过程中， 对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。</p>
<p>总结一下：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</p>
<h2 id="10-4-泛型通配符"><a href="#10-4-泛型通配符" class="headerlink" title="10.4 泛型通配符"></a>10.4 泛型通配符</h2><p>我们知道Ingeter是Number的一个子类，同时在特性章节中我们也验证过Generic与Generic实际上是相同的一种基本类型。那么问题来了，在使用Generic作为形参的方法中，能否使用Generic的实例传入呢？在逻辑上类似于Generic和Generic是否可以看成具有父子关系的泛型类型呢？</p>
<p>弄清楚这个问题，使用Generic这个泛型类继续看下面的例子：</p>
<p>public void showKeyValue1(Generic<Number> obj){</p>
<p>Log.d(“泛型测试”,”key value is “ + obj.getKey());</p>
<p>}</p>
<p>Generic<Integer> gInteger &#x3D; new Generic<Integer>(123);</p>
<p>Generic<Number> gNumber &#x3D; new Generic<Number>(456);</p>
<p>showKeyValue(gNumber);</p>
<p>&#x2F;&#x2F; showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt;</p>
<p>&#x2F;&#x2F; cannot be applied to Generic&lt;java.lang.Number&gt;</p>
<p>&#x2F;&#x2F; showKeyValue(gInteger);</p>
<p>在提示信息中，我们可以看到Generic不能被看作为 Generic的子类。</p>
<p>由此可以看出:同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。</p>
<p>再回到上面的例子，那么究竟如何解决上面的问题呢?</p>
<p>或许我们需要一个在逻辑上可以表示同时是Generic和Generic父类的引用类型。至此类型通配符应运而生。</p>
<p>我们可以将上面的方法改一下:</p>
<p>public void showKeyValue1(Generic&lt;?&gt; obj){</p>
<p>Log.d(“泛型测试”,”key value is “ + obj.getKey());</p>
<p>}</p>
<p>类型通配符一般是使用？ 代替具体的类型实参，注意了，此处？ 是类型实参，而不是类型形参。</p>
<h2 id="要说三遍"><a href="#要说三遍" class="headerlink" title="要说三遍!"></a>要说三遍!</h2><p>此处? 是类型实参，而不是类型形参!</p>
<p>此处? 是类型实参，而不是类型形参!</p>
<p>再直白点的意思就是，此处的? 和Number、String、Integer一样都是一种实际的类型，可以把? 看成所有类型的父类。是一种真实的类型。</p>
<p>可以解决当具体类型不确定的时候，这个通配符就是？。</p>
<p>当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用？通配符来表未知类型。</p>
<h2 id="10-5-泛型上下边界"><a href="#10-5-泛型上下边界" class="headerlink" title="10.5 泛型上下边界"></a>10.5 泛型上下边界</h2><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p>
<p>添加上边界，就是指传入的类型实参必须是指定类型的子类型。</p>
<p>public void showKeyValue1(Generic&lt;? extends Number&gt; obj){</p>
<p>Log.d(“泛型测试”,”key value is “ + obj.getKey());</p>
<p>}</p>
<p>Generic<String> generic1 &#x3D; new Generic<String>(“s”);</p>
<p>Generic<Integer> generic2 &#x3D; new Generic<Integer>(1314520);</p>
<p>Generic<Float> generic3 &#x3D; new Generic<Float>(11.11f);</p>
<p>Generic<Double> generic4 &#x3D; new Generic<Double>(3.14);</p>
<p>&#x2F;&#x2F;这一行代码编译器会提示错误, 因为string类型并不是Number类型的子类</p>
<p>&#x2F;&#x2F;showKeyValue1(generic1);</p>
<p>showKeyValue1(generic2);</p>
<p>showKeyValue1(generic3);</p>
<p>showKeyValue1(generic4);</p>
<p>如果再把把泛型类的定义也改一下:</p>
<p>public class Generic<T extends Number>{</p>
<p>private ( T ) key;</p>
<p>public Generic(T key) {</p>
<p>this.key ( &#x3D; ) key;</p>
<p>}</p>
<p>public T getKey(){</p>
<p>return key;</p>
<p>}</p>
<p>}</p>
<p>&#x2F;&#x2F;这一行代码也会报错, 因为String不是Number的子类</p>
<p>Generic<String> generic1 &#x3D; new Generic<String>(“11111”);</p>
<p>我们发现：泛型的上下边界添加，必须与泛型的声明在一起。</p>
<h2 id="10-6-泛型存在的约束"><a href="#10-6-泛型存在的约束" class="headerlink" title="10.6 泛型存在的约束"></a>10.6 泛型存在的约束</h2><ul>
<li><p>无法实例化泛型类</p>
</li>
<li><p>无法使用instanceof关键字或&#x3D;&#x3D;判断泛型类的类型</p>
</li>
<li><p>泛型类不能继承Exception或者Throwable</p>
</li>
<li><p>不能捕获泛型类型限定的异常但可以将泛型限定的异常抛出</p>
</li>
<li><p>泛型类的原生类型与所传递的泛型无关，无论传递什么类型，原生类是一样的</p>
</li>
<li><p>静态变量或方法不能引用泛型类型变量，但是静态泛型方法是可以的</p>
</li>
<li><p>基本类型无法作为泛型类型</p>
</li>
<li><p>泛型数组可以声明但无法实例化</p>
</li>
</ul>
<p>更多关于Java泛型的有意思的学习经历也需要靠大家在日常工作中认真去体会啦~</p>
<h1 id="11-Java-枚举"><a href="#11-Java-枚举" class="headerlink" title="11. Java 枚举"></a>11. Java 枚举</h1><h2 id="11-1-什么是枚举"><a href="#11-1-什么是枚举" class="headerlink" title="11.1 什么是枚举?"></a>11.1 什么是枚举?</h2><p>枚举是Java1.5引入的新特性，通过关键字enum来定义枚举类。枚举类是一种特殊类，它和普通类一样可以使用构造器、定义成员变量和方法，也能实现一个或多个接口,但枚举类不能继承其他类。</p>
<p>例如，你要指定一整个星期的天的枚举类型是:</p>
<p>public enum Day {</p>
<p>SUNDAY, MONDAY, TUESDAY, WEDNESDAY,</p>
<p>THURSDAY, FRIDAY, SATURDAY</p>
<p>}</p>
<p>我们应该在需要使用固定组常量的任何时候使用枚举类型。这包括自然枚举类型，例如银河系的行星，</p>
<p>这些你可以在编译时知道任何可能值。还有菜单选择，命令行标志等。</p>
<h2 id="11-2-如何声明枚举类型？"><a href="#11-2-如何声明枚举类型？" class="headerlink" title="11.2 如何声明枚举类型？"></a>11.2 如何声明枚举类型？</h2><p>这里有一些介绍如何使用Day枚举类型声明的代码，如下:</p>
<p>public class EnumTest {</p>
<p>Day day;</p>
<p>public EnumTest(Day day) {</p>
<p>this.day ( &#x3D; ) day;</p>
<p>}</p>
<p>public void tellItLikeItIs() {</p>
<p>switch (day) {</p>
<p>case MONDAY:</p>
<p>System.out.println(“Mondays are bad.”);</p>
<p>break;</p>
<p>case FRIDAY:</p>
<p>System.out.println(“Fridays are better.”);</p>
<p>break;</p>
<p>case SATURDAY: case SUNDAY:</p>
<p>System.out.println(“Weekends are best.”);</p>
<p>break;</p>
<p>default:</p>
<p>System.out.println(“Midweek days are so-so.”);</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>EnumTest firstDay ( &#x3D; ) new EnumTest(Day.MONDAY);</p>
<p>firstDay.tellItLikeItIs();</p>
<p>EnumTest thirdDay &#x3D; new EnumTest(Day.WEDNESDAY);</p>
<p>thirdDay.tellItLikeItIs();</p>
<p>EnumTest fifthDay &#x3D; new EnumTest(Day.FRIDAY);</p>
<p>fifthDay.tellItLikeItIs();</p>
<p>EnumTest sixthDay &#x3D; new EnumTest(Day.SATURDAY);</p>
<p>sixthDay.tellItLikeItIs();</p>
<p>EnumTest seventhDay &#x3D; new EnumTest(Day.SUNDAY);</p>
<p>seventhDay.tellItLikeItIs();</p>
<p>}</p>
<p>}</p>
<h2 id="上述代码输出为"><a href="#上述代码输出为" class="headerlink" title="上述代码输出为:"></a>上述代码输出为:</h2><p>Mondays are bad.</p>
<p>Midweek days are so-so.</p>
<p>Fridays are better.</p>
<p>weekends are best.</p>
<p>weekends are best.</p>
<p>注意：任意两个枚举成员不能具有相同的名称，且它的常数值必须在该枚举的基础类型的范围之内，多个枚举成员之间使用逗号分隔。</p>
<p>如果没有显式地声明基础类型的枚举，那么意味着它所对应的基础类型是 int。</p>
<h2 id="11-2-1-枚举类"><a href="#11-2-1-枚举类" class="headerlink" title="11.2.1 枚举类"></a>11.2.1 枚举类</h2><p>Java 中的每一个枚举都继承自 java.lang.Enum 类。当定义一个枚举类型时，每一个枚举类型成员都可以看作是 Enum 类的实例，这些枚举成员默认都被 final、public, static 修饰，当使用枚举类型成员时，直接使用枚举名称调用成员即可。</p>
<table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tr><td>values()</td><td>以数组形式返回枚举类型的所有成员</td></tr><tr><td>valueOf()</td><td>将普通字符串转换为枚举实例</td></tr><tr><td>compareTo()</td><td>比较两个枚举成员在定义时的顺序</td></tr><tr><td>ordinal()</td><td>获取枚举成员的索引位置</td></tr></table>

<h2 id="11-3-从宇宙入手深入了解枚举类型"><a href="#11-3-从宇宙入手深入了解枚举类型" class="headerlink" title="11.3 从宇宙入手深入了解枚举类型"></a>11.3 从宇宙入手深入了解枚举类型</h2><p>Java编程语言枚举类型比其他编程语言更加强大。enum声明，定义了类(称为enum类型)。枚举类体， 可以包含方法和其他字段。编译器为enum自动添加特殊的方法。例如，有一个静态的values方法，返回一个按照声明顺序排列的enum值数组。这个方法通常结合for-each结构，遍历enum类型的所有值。例如，下面Planet类里的代码，演示了遍历银河系的所有行星。</p>
<p>for (Planet ( p ) : Planet.values()) {</p>
<p>System.out.printf(“Your weight on %s is %f%n”,</p>
<p>p, p.surfaceweight(mass));</p>
<p>}</p>
<p>所有enum类隐式继承java.lang.Enum。由于java不支持多继承，所有enum也不能继承其他类。</p>
<p>Planet是一个枚举类型，代表银河系里的所有行星。他们是恒定的质量和半径属性定义。</p>
<p>每个枚举常量都有质量和半径参数的声明。这些值，通过构造方法，在常量初始化时传递进来。java要求常量首先定义，其次才是字段和方法。所以，在字段和方法之前，enum常量列表必须以分号(;)结束。</p>
<p>注意：enum类型的构造方法必须是包内私有或者是private访问。它自动创建在enum体内的开始创建声明的常量，不允许直接调用enum的构造方法。</p>
<p>对于它的属性和构造方法，行星上有自己的方法，您可以检索每个行星的表面引力和重量。下面是一个示例程序，根据你在地球的体重(任何单位),计算并打印你在所有的行星的体重（相同单位）：</p>
<p>public enum Planet {</p>
<p>MERCURY (3.303e+23, 2.4397e6),</p>
<p>VENUS (4.869e+24, 6.0518e6),</p>
<p>EARTH (5.976e+24, 6.37814e6),</p>
<p>MARS (6.421e+23, 3.3972e6),</p>
<p>JUPITER (1.9e+27, 7.1492e7),</p>
<p>SATURN (5.688e+26, 6.0268e7),</p>
<p>URANUS (8.686e+25, 2.5559e7),</p>
<p>NEPTUNE (1.024e+26, 2.4746e7);</p>
<p>private final double mass; &#x2F;&#x2F; in kilograms</p>
<p>private final double radius; &#x2F;&#x2F; in meters</p>
<p>Planet(double mass, double radius) {</p>
<p>this.mass ( &#x3D; ) mass;</p>
<p>this.radius ( &#x3D; ) radius;</p>
<p>}</p>
<p>private double mass() { return mass; }</p>
<p>private double radius() { return radius; }</p>
<p>&#x2F;&#x2F; universal gravitational constant (m3 kg-1 s-2)</p>
<p>public static final double ( G &#x3D; {6.67300E} - {11} ) ;</p>
<p>double surfaceGravity() {</p>
<p>return G * mass &#x2F; (radius * radius);</p>
<p>}</p>
<p>double surfaceweight(double otherMass) {</p>
<p>return otherMass * surfaceGravity();</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>if (args.length ( ! &#x3D; 1 ) ) {</p>
<p>System.err.println(“Usage: java Planet <earth_weight>“);</p>
<p>System.exit(-1);</p>
<p>}</p>
<p>double earthweight ( &#x3D; ) Double.parseDouble(args[0]);</p>
<p>double mass ( &#x3D; ) earthweight&#x2F;EARTH.surfaceGravity();</p>
<p>for (Planet ( p ) : Planet.values ())</p>
<p>System.out.printf(“Your weight on %s is %f%n”,</p>
<p>p, p.surfaceweight(mass));</p>
<p>} }</p>
<p>如果在命令行运行Planet.class，参数是175，输出是:</p>
<p>$ java Planet 175</p>
<p>Your weight on MERCURY is 66.107583</p>
<p>Your weight on VENUS is 158.374842</p>
<p>Your weight on EARTH is 175.000000</p>
<p>Your weight on MARS is 66.279007</p>
<p>YOUR WEIGHTER IS 442.847567</p>
<p>Your weight on SATURN is 186.552719</p>
<p>Your weight on URANUS is 158.397260</p>
<p>Your weight on NEPTUNE is 199.207413</p>
<h2 id="11-4-EnumMap-与-EnumSet"><a href="#11-4-EnumMap-与-EnumSet" class="headerlink" title="11.4 EnumMap 与 EnumSet"></a>11.4 EnumMap 与 EnumSet</h2><p>为了更好地支持枚举类型，java.util 中添加了两个新类：EnumMap 和 EnumSet。使用它们可以更高效地操作枚举类型。</p>
<ul>
<li>EnumMap 类</li>
</ul>
<p>EnumMap 是专门为枚举类型量身定做的 Map 实现。虽然使用其他的 Map（如 HashMap）实现也能完成枚举类型实例到值的映射，但是使用 EnumMap 会更加高效。</p>
<ul>
<li>HashMap 只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以 EnumMap 使用数组来存放与枚举类型对应的值，使得 EnumMap 的效率非常高。</li>
</ul>
<p>下面是使用 EnumMap 的一个代码示例。枚举类型 DataBaseType 里存放了现在支持的所有数据库类型。针对不同的数据库，一些数据库相关的方法需要返回不一样的值，例如示例中 getURL() 方法。</p>
<p>&#x2F;&#x2F;定义数据库类型枚举</p>
<p>public enum DataBaseType</p>
<p>{</p>
<p>MYSQUORACLE , DB2 , SQLSERVER</p>
<p>}</p>
<p>&#x2F;&#x2F;某类中定义的获取数据库URL的方法以及EnumMap的声明</p>
<p>private EnumMap&lt;DataBaseType, String&gt;urls&#x3D;new EnumMap&lt;DataBaseType, String&gt;</p>
<p>(DataBaseType.class);</p>
<p>public DataBaseInfo()</p>
<p>{</p>
<p>urls.put(DataBaseType.DB2,”jdbc:db2:&#x2F;&#x2F;localhost:5000&#x2F;sample”);</p>
<p>urls.put(DataBaseType.MYSQL,”jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;mydb”);</p>
<p>urls.put(DataBaseType.ORACLE, “jdbc:oracle:thin:@localhost:1521:sample”);</p>
<p>urls . put (DataBaseType . SQLSERVER, “jdbc : microsoft : sq1server : &#x2F;&#x2F;sq1 : 1433 ; Database&#x3D;myd</p>
<p>b”);</p>
<p>}</p>
<p>&#x2F;&#x2F;根据不同的数据库类型, 返回对应的URL</p>
<p>&#x2F;&#x2F;@param type DataBaseType 枚举类新实例</p>
<p>&#x2F;&#x2F;@return</p>
<p>public String getURL(DataBaseType type)</p>
<p>{</p>
<p>return this.urls.get(type);</p>
<p>}</p>
<p>在实际使用中，EnumMap对象urls往往是由外部负责整个应用初始化的代码来填充的。</p>
<p>从本例中可以看出，使用EnumMap可以很方便地为枚举类型在不同的环境中绑定到不同的值上。本例子中getURL绑定到URL上，在其他的地方可能又被绑定到数据库驱动上去。</p>
<h2 id="EnumSet-类"><a href="#EnumSet-类" class="headerlink" title="EnumSet 类"></a>EnumSet 类</h2><p>EnumSet 是枚举类型的高性能 Set 实现，它要求放入它的枚举常量必须属于同一枚举类型。EnumSet 提供了许多工厂方法以便于初始化，如表 2 所示</p>
<table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tr><td>of(E first, e...rest)</td><td>创建包含指定枚举成员的 EnumSet 对象</td></tr><tr><td>allOf(Class element type)</td><td>创建一个包含指定枚举类型中所有枚举成员的 EnumSet 对象</td></tr><tr><td>range(E from, E to)</td><td>创建一个 EnumSet 对象，该对象包含了 from 到 to 之间的所有 枚举成员</td></tr><tr><td>complementOf(EnumSet s)</td><td>创建一个与指定 EnumSet 对象 s 相同的枚举类型 EnumSet 对 象，并包含所有 s 中未包含的枚举成员</td></tr><tr><td>copyOf(EnumSet s)</td><td>创建一个与指定 EnumSet 对象 s 相同的枚举类型 EnumSet 对 象，并与 s 包含相同的枚举成员</td></tr></table>



<table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tr><td>noneOf(<Class elementType)</td><td>创建指定枚举类型的空 EnumSet 对象</td></tr></table>

<h2 id="11-5-使用枚举类型的优势"><a href="#11-5-使用枚举类型的优势" class="headerlink" title="11.5 使用枚举类型的优势"></a>11.5 使用枚举类型的优势</h2><p>枚举类型声明提供了一种用户友好的变量定义方法，枚举了某种数据类型所有可能出现的值。总结枚举类型，有以下特点:</p>
<ul>
<li><p>类型安全</p>
</li>
<li><p>紧凑有效的数据定义</p>
</li>
<li><p>可以和程序其他部分完美交互</p>
</li>
<li><p>运行效率高</p>
</li>
</ul>
<p>更多关于Java泛型的有意思的学习经历也需要靠大家在日常工作中认真去体会啦~</p>
<h1 id="12-Java-8-新特性"><a href="#12-Java-8-新特性" class="headerlink" title="12. Java 8 新特性"></a>12. Java 8 新特性</h1><h2 id="12-1-Java-8-简介"><a href="#12-1-Java-8-简介" class="headerlink" title="12.1 Java 8 简介"></a>12.1 Java 8 简介</h2><p>Java 8是Java自 Java 5 (发布于2004年) 之后的最重要的版本。这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。在本文中我们将学习这些新特性，并用实际的例子说明在什么场景下适合使用。</p>
<p>本文中我们假设Java开发者经常面对的几类问题:</p>
<ul>
<li><p>语言</p>
</li>
<li><p>编译器</p>
</li>
<li><p>库</p>
</li>
</ul>
<p>。 工具</p>
<ul>
<li>运行时 (JVM)</li>
</ul>
<h2 id="12-2-Java-8-特性详解"><a href="#12-2-Java-8-特性详解" class="headerlink" title="12.2 Java 8 特性详解"></a>12.2 Java 8 特性详解</h2><h2 id="12-2-1-Lambda表达式和函数式接口"><a href="#12-2-1-Lambda表达式和函数式接口" class="headerlink" title="12.2.1 Lambda表达式和函数式接口"></a>12.2.1 Lambda表达式和函数式接口</h2><p>Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理：函数式开发者非常熟悉这些概念。如果没有lambda， Stream用起来相当别扭，他会产生大量的匿名内部类，所以lambda+default method使得jdk库更加强大，以及灵活，Stream以及集合框架的改进便是最好的证明。</p>
<p>(1). Lambda的设计耗费了很多时间和很大的社区力量，最终找到一种折中的实现方案，可以实现简洁而紧凑的语言结构。</p>
<p>Arrays.asList(“a”, “b”, “d”).forEach( e -&gt; System.out.println( e ));</p>
<p>上面这个代码中的参数e的类型是由编译器推理得出的，你也可以显式指定该参数的类型，例如：</p>
<p>Arrays.asList(“a”, “b”, “d”).forEach( (String e ) -&gt; System.out.println( e ) );</p>
<p>(2). 当Lambda表达式需要更复杂的语句块时，可以使用花括号将该语句块括起来，类似于Java中的函数体，例如:</p>
<p>Arrays.asList(“a”, “b”, “d”).forEach( e -&gt; {</p>
<p>System.out.print( e );</p>
<p>System.out.print( e );</p>
<p>});</p>
<p>(3). Lambda表达式可以引用类成员和局部变量（会将这些变量隐式得转换成final的），下列两个代码块的效果一致:</p>
<p>String separator ( &#x3D; ) “,”;</p>
<p>Arrays.asList(“a”, “b”, “d”).forEach(</p>
<p>( String e ) -&gt; System.out.print( e + separator ) );</p>
<p>final String separator ( &#x3D; ) “,”;</p>
<p>Arrays.asList(“a”, “b”, “d”).forEach(</p>
<p>( String e ) -&gt; System.out.print( e + separator ) );</p>
<p>(4). Lambda表达式是可以有返回值的，返回值的类型也由编译器推理得出。如果Lambda表达式中的语句块只有一行，则可以不用使用return语句，具体如下：</p>
<p>Arrays.asList(“a”, “b”, “d”).sort(( e1, e2)) -&gt; e1.compareTo( e2 ));</p>
<p>Arrays.asList(“a”, “b”, “d” ).sort( ( e1, e2 ) -&gt; {</p>
<p>int result ( &#x3D; ) e1.compareTo(e2);</p>
<p>return result;</p>
<p>});</p>
<p>为了让现有的功能与Lambda表达式良好兼容，函数接口应运而生。函数接口指的是只有一个函数的接 ( ▱ ) ，这样的接口可以隐式转换为Lambda表达式。java.lang.Runnable和java.util.concurrent.Callable是函数式接口的最佳例子。在实践中，函数式接口非常脆弱：只要某个开发者在该接口中添加一个函数， 则该接口就不再是函数式接口进而导致编译失败。为了克服这种代码层面的脆弱性，并显式说明某个接口是函数式接口，Java 8 提供了一个特殊的注解@FunctionalInterface，举个简单的函数式接口的定义:</p>
<p>@FunctionalInterface</p>
<p>public interface Functional {</p>
<p>void method();</p>
<p>}</p>
<p>如果你需要了解更多Lambda表达式的细节，一定要去看看官方文档哦。</p>
<h2 id="12-2-2-方法引用"><a href="#12-2-2-方法引用" class="headerlink" title="12.2.2 方法引用"></a>12.2.2 方法引用</h2><p>方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。</p>
<p>举个例子:</p>
<hr>
<p>public static class Car {</p>
<p>public static Car create( final Supplier&lt; Car &gt; supplier ) {</p>
<p>return supplier.get();</p>
<p>}</p>
<p>public static void collide( final Car car ) {</p>
<p>System.out.println( “Collided” + car.toString() );</p>
<p>}</p>
<p>public void follow( final Car another ) {</p>
<p>System.out.println( “Following the “ + another.toString() );</p>
<p>}</p>
<p>public void repair() {</p>
<p>System.out.println( “Repaired “ + this.toString() );</p>
<p>}</p>
<p>}</p>
<hr>
<p>方法一引用的类型是构造器引用，语法是Class::new，或者更一般的形式：Class::new。注意：这个构造器没有参数。</p>
<p>final car car &#x3D; Car.create( Car::new );</p>
<p>final List&lt; Car &gt; cars &#x3D; Arrays.asList( car );</p>
<p>方法二引用的类型是静态方法引用，语法是Class::static_method。注意：这个方法接受一个Car类型的参数。</p>
<p>cars.forEach( Car::collide );</p>
<p>方法三引用的类型是某个实例对象的成员方法的引用，语法是instance::method。注意：这个方法接受一个Car类型的参数:</p>
<p>final Car police ( &#x3D; ) Car.create(Car::new);</p>
<p>cars.forEach( police::follow );</p>
<p>方法四引用的类型是某个类的成员方法的引用，语法是Class::method，注意，这个方法没有定义入参：</p>
<p>cars.forEach( Car::repair );</p>
<p>运行上述例子，可以在控制台看到如下输出（Car实例可能不同）：</p>
<p>collided com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d Repaired com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d Following the</p>
<p>com. javacodegeeks . java8 . method . references . MethodReferences $Car@7a81197d</p>
<h2 id="12-2-3-接口的默认方法和静态方法"><a href="#12-2-3-接口的默认方法和静态方法" class="headerlink" title="12.2.3 接口的默认方法和静态方法"></a>12.2.3 接口的默认方法和静态方法</h2><p>Java 8使用两个新概念扩展了接口的含义：默认方法和静态方法。默认方法使得接口有点类似traits，不过要实现的目标不一样。默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。</p>
<p>默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，例子代码如下:</p>
<hr>
<p>private interface Defaulable {</p>
<p>&#x2F;&#x2F; Interfaces now allow default methods, the implementer may or</p>
<p>&#x2F;&#x2F; may not implement (override) them.</p>
<p>default String notRequired() {</p>
<p>return “Default implementation”;</p>
<p>}</p>
<p>}</p>
<p>private static class DefaultableImpl implements Defaulable {</p>
<p>}</p>
<p>private static class OverridableImpl implements Defaulable {</p>
<p>@override</p>
<p>public string notRequired() {</p>
<p>return “Overridden implementation”;</p>
<p>}</p>
<p>}</p>
<hr>
<p>Defaulable接口使用关键字default定义了一个默认方法notRequired()。DefaultableImpl类实现了这个接口，同时默认继承了这个接口中的默认方法；OverridableImpl类也实现了这个接口，但覆写了该接口的默认方法，并提供了一个不同的实现。</p>
<p>Java 8的另一个有趣的特性是在接口中定义静态方法，例子代码如下：</p>
<p>private interface DefaulableFactory {</p>
<p>&#x2F;&#x2F; Interfaces now allow static methods</p>
<p>static Defaulable create( Supplier&lt; Defaulable &gt; supplier ) {</p>
<p>return supplier.get();</p>
<p>}</p>
<p>}</p>
<p>下面的代码片段整合了默认方法和静态方法的使用场景：</p>
<p>public static void main( String[] args ) {</p>
<p>Defaulable defaulable ( &#x3D; ) DefaulableFactory.create(DefaultableImpl::new);</p>
<p>System.out.println( defaulable.notRequired());</p>
<p>defaulable ( &#x3D; ) DefaulableFactory.create(OverridableImpl::new);</p>
<p>System.out.println( defaulable.notRequired()); }</p>
<p>这段代码的输出结果如下:</p>
<p>Default implementation</p>
<p>Overridden implementation</p>
<p>由于JVM上的默认方法的实现在字节码层面提供了支持，因此效率非常高。默认方法允许在不打破现有继</p>
<p>承体系的基础上改进接口。该特性在官方库中的应用是：给java.util.Collection接口添加新方法，如</p>
<p>stream()、parallelStream()、forEach()和removeIf()等等。</p>
<h2 id="12-2-4-更好的类型推断"><a href="#12-2-4-更好的类型推断" class="headerlink" title="12.2.4 更好的类型推断"></a>12.2.4 更好的类型推断</h2><p>Java 8编译器在类型推断方面有很大的提升，在很多场景下编译器可以推导出某个参数的数据类型，从而使得代码更为简洁。例子代码如下:</p>
<hr>
<p>package com.javacodegeeks.java8.type.inference;</p>
<p>public class value&lt; ( T &gt; { )</p>
<p>public static&lt; ( T &gt; T ) defaultvalue() {</p>
<p>return null;</p>
<p>}</p>
<p>public ( T ) getOrDefault( ( T ) value, ( T ) defaultvalue ( ){ )</p>
<p>return ( value !&#x3D; null ) ? value : defaultvalue;</p>
<p>}</p>
<p>}</p>
<hr>
<h2 id="下列代码是Value类型的应用"><a href="#下列代码是Value类型的应用" class="headerlink" title="下列代码是Value类型的应用:"></a>下列代码是Value类型的应用:</h2><p>package com.javacodegeeks.java8.type.inference;</p>
<p>public class TypeInference {</p>
<p>public static void main(String[] args) {</p>
<p>final value&lt; String ( &gt; ) value ( &#x3D; ) new value ( &lt; &gt; \left( \right) ) ;</p>
<p>value.getOrDefault(“22”, value.defaultvalue());</p>
<p>}</p>
<p>}</p>
<p>参数Value.defaultValue()的类型由编译器推导得出，不需要显式指明。在Java 7中这段代码会有编译错误，除非使用Value.defaultValue()。</p>
<h2 id="12-2-5-重复注解"><a href="#12-2-5-重复注解" class="headerlink" title="12.2.5 重复注解"></a>12.2.5 重复注解</h2><p>自从Java 5中引入注解以来，这个特性开始变得非常流行，并在各个框架和项目中被广泛使用。不过，注解有一个很大的限制是：在同一个地方不能多次使用同一个注解。Java 8打破了这个限制，引入了重复注解的概念，允许在同一个地方多次使用同一个注解。</p>
<p>在Java 8中使用@Repeatable注解定义重复注解，实际上，这并不是语言层面的改进，而是编译器做的一个trick，底层的技术仍然相同。可以利用下面的代码说明：</p>
<hr>
<p>package com.javacodegeeks.java8.repeatable.annotations;</p>
<p>import java.lang.annotation.ElementType;</p>
<p>import java.lang.annotation.Repeatable;</p>
<p>import java.lang.annotation.Retention;</p>
<hr>
<hr>
<p>import java.lang.annotation.RetentionPolicy;</p>
<p>import java.lang.annotation.Target;</p>
<p>public class RepeatingAnnotations {</p>
<p>@Target( ElementType.TYPE )</p>
<p>@Retention( RetentionPolicy.RUNTIME )</p>
<p>public @interface Filters {</p>
<p>Filter[] value();</p>
<p>}</p>
<p>@Target( ElementType.TYPE )</p>
<p>@Retention( RetentionPolicy.RUNTIME )</p>
<p>@Repeatable( Filters.class )</p>
<p>public @interface Filter {</p>
<p>String value();</p>
<p>};</p>
<p>@Filter(“filter1”)</p>
<p>@Filter(“filter2”)</p>
<p>public interface Filterable {</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>for( Filter filter: Filterable.class.getAnnotationsByType( Filter.class )</p>
<p>) {</p>
<p>System.out.println( filter.value() );</p>
<p>}</p>
<p>}</p>
<p>}</p>
<hr>
<p>如上所见，这的Filter类使用@Repeatable(Filters.class)注解修饰，而Filters是存放Filter注解的容器，编译器尽量对开发者屏蔽这些细节。这样就会导致，Filterable接口可以用两个Filter注解注释（这里并没有提到任何关于Filters的信息）。</p>
<p>另外，反射API提供了一个新的方法：getAnnotationsByType()，可以返回某个类型的重复注解，例如 Filterable.class.getAnnoation(Filters.class)将返回两个Filter实例，输出到控制台的内容如下所示：</p>
<p>filter1</p>
<p>filter2</p>
<h2 id="12-2-6-拓展注解"><a href="#12-2-6-拓展注解" class="headerlink" title="12.2.6 拓展注解"></a>12.2.6 拓展注解</h2><p>Java 8拓宽了注解的应用场景。现在，注解几乎可以使用在任何元素上：局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上。下面是一些例子：</p>
<p>package com.javacodegeeks.java8.annotations;</p>
<p>import java.lang.annotation.ElementType;</p>
<p>import java.lang.annotation.Retention;</p>
<p>import java.lang.annotation.RetentionPolicy;</p>
<p>import java.lang.annotation.Target;</p>
<p>import java.util.ArrayList;</p>
<p>import java.util.Collection;</p>
<p>public class Annotations {</p>
<p>@Retention( RetentionPolicy.RUNTIME )</p>
<p>@Target( { ElementType.TYPE_USE, ElementType.TYPE_PARAMETER })</p>
<p>public @interface NonEmpty {</p>
<p>}</p>
<p>public static class Holder&lt; @NonEmpty T &gt; extends @NonEmpty object {</p>
<p>public void method() throws @NonEmpty Exception {</p>
<p>}</p>
<p>}</p>
<p>@Suppresswarnings(“unused”)</p>
<p>public static void main(String[] args) {</p>
<p>final Holder&lt; String &gt; holder &#x3D; new @NonEmpty Holder&lt; String &gt;();</p>
<p>@NonEmpty Collection&lt; @NonEmpty String &gt; strings &#x3D; new ArrayList&lt;&gt;(); } }</p>
<p>ElementType.TYPE_USER和ElementType.TYPE_PARAMETER是Java 8新增的两个注解，用于描述注解的使用场景。Java 语言也做了对应的改变，以识别这些新增的注解。</p>
<h2 id="12-2-7-Java编译器的新特性"><a href="#12-2-7-Java编译器的新特性" class="headerlink" title="12.2.7 Java编译器的新特性"></a>12.2.7 Java编译器的新特性</h2><p>为了在运行时获得Java程序中方法的参数名称，老一辈的Java程序员必须使用不同方法，例如</p>
<p>Paranamer liberary。Java 8终于将这个特性规范化，在语言层面（使用反射API和</p>
<p>Parameter.getName()方法）和字节码层面（使用新的javac编译器以及-parameters参数）提供支持。</p>
<p>package com.javacodegeeks.java8.parameter.names;</p>
<p>import java.lang.reflect.Method;</p>
<p>import java.lang.reflect.Parameter;</p>
<p>public class ParameterNames {</p>
<p>public static void main(String[] args) throws Exception {</p>
<p>Method method &#x3D; ParameterNames.class.getMethod(“main”, String[].class );</p>
<p>for( final Parameter parameter: method.getParameters() ) {</p>
<p>System.out.println(“Parameter: “ + parameter.getName() );</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>在Java 8中这个特性是默认关闭的，因此如果不带-parameters参数编译上述代码并运行，则会输出如下结果:</p>
<p>Parameter: arg0</p>
<p>如果带-parameters参数，则会输出如下结果（正确的结果）：</p>
<p>Parameter: args</p>
<p>如果你使用Maven进行项目管理，则可以在maven-compiler-plugin编译器的配置项中配置-parameters 参数:</p>
<plugin>

<p><groupId>org.apache.maven.plugins</groupId></p>
<p><artifactId>maven-compiler-plugin</artifactId></p>
<p><version>3.1</version></p>
<configuration>

<p><compilerArgument>-parameters</compilerArgument></p>
<source>1.8</source>

<p><target>1.8</target></p>
</configuration>

</plugin>

<h4 id="12-2-8-Optional"><a href="#12-2-8-Optional" class="headerlink" title="12.2.8 Optional"></a>12.2.8 Optional</h4><p>Java应用中最常见的bug就是空值异常。在Java 8之前，Google Guava引入了Optionals类来解决</p>
<p>NullPointerException，从而避免源码被各种null检查污染，以便开发者写出更加整洁的代码。Java 8也将Optional加入了官方库。</p>
<p>Optional仅仅是一个容易：存放T类型的值或者null。它提供了一些有用的接口来避免显式的null检查， 可以参考Java 8官方文档了解更多细节。</p>
<p>接下来看一点使用Optional的例子：可能为空的值或者某个类型的值：</p>
<p>Optional&lt; String &gt; fullName &#x3D; Optional.ofNullable( null );</p>
<p>System.out.println(“Full Name is set?” + fullName.isPresent() );</p>
<p>System.out.println(“Full Name: “ + fullName.orElseGet( () -&gt; “[none]” ) );</p>
<p>System.out.println( fullName.map( s -&gt; “Hey” + s + “!” ).orElse( “Hey Stranger!” ））；</p>
<p>如果Optional实例持有一个非空值，则isPresent()方法返回true，否则返回false；orElseGet()方法， Optional实例持有null，则可以接受一个lambda表达式生成的默认值；map()方法可以将现有的 Opetional实例的值转换成新的值；orElse()方法与orElseGet()方法类似，但是在持有null的时候返回传入的默认值。</p>
<p>输出结果如下:</p>
<p>Full Name is set? false</p>
<p>Full Name: [none]</p>
<p>Hey Stranger!</p>
<h2 id="12-2-9-Streams"><a href="#12-2-9-Streams" class="headerlink" title="12.2.9 Streams"></a>12.2.9 Streams</h2><p>新增的Stream API（java.util.stream）将生成环境的函数式编程引入了Java库中。这是目前为止最大的一次对Java库的完善，以便开发者能够写出更加有效、更加简洁和紧凑的代码。</p>
<p>Steam API极大得简化了集合操作（后面我们会看到不止是集合），首先看下这个叫Task的类：</p>
<p>public class Streams {</p>
<p>private enum Status {</p>
<p>OPEN, CLOSED</p>
<p>};</p>
<p>private static final class Task {</p>
<p>private final Status status;</p>
<p>private final Integer points;</p>
<hr>
<p>Task( final Status status, final Integer points ) {</p>
<p>this.status ( &#x3D; ) status;</p>
<p>this.points ( &#x3D; ) points;</p>
<p>}</p>
<p>public Integer getPoints() {</p>
<p>return points;</p>
<p>}</p>
<p>public Status getStatus() {</p>
<p>return status;</p>
<p>}</p>
<p>@override</p>
<p>public string tostring() {</p>
<p>return String.format(“[%s, %d]”, status, points );</p>
<p>}</p>
<p>} }</p>
<hr>
<p>Task类有一个分数 (或伪复杂度) 的概念，另外还有两种状态：OPEN或者CLOSED。现在假设有一个 task集合:</p>
<p>final Collection&lt; Task &gt; tasks &#x3D; Arrays.asList(</p>
<p>new Task( Status.OPEN, 5 ),</p>
<p>new Task( Status.OPEN, 13 ),</p>
<p>new Task( Status.CLOSED, 8 )</p>
<p>);</p>
<p>试想一下：在这个task集合中一共有多少个处于OPEN状态的点？在Java 8之前，要解决这个问题，则需要使用foreach循环遍历task集合；但是在Java 8中可以利用steams解决：包括一系列元素的列表，并且支持顺序和并行处理。</p>
<p>&#x2F;&#x2F; Calculate total points of all active tasks using sum()</p>
<p>final long totalPointsOfOpenTasks &#x3D; tasks</p>
<p>.stream()</p>
<p>.filter( task -&gt; task.getStatus() &#x3D;&#x3D; Status.OPEN )</p>
<p>.mapToInt( Task::getPoints )</p>
<p>.sum();</p>
<p>System.out.println( “Total points: “ + totalPointsOfOpenTasks );</p>
<p>运行这个方法的控制台输出是:</p>
<p>Total points: 18</p>
<ul>
<li><p>tasks集合被转换成steam表示;</p>
</li>
<li><p>在steam上的filter操作会过滤掉所有CLOSED的task;</p>
</li>
<li><p>mapToInt操作基于每个task实例的Task::getPoints方法将task流转换成Integer集合;</p>
</li>
<li><p>通过sum方法计算总和，得出最后的结果。</p>
</li>
</ul>
<h2 id="12-2-10-Date-Time-API-JSR-310"><a href="#12-2-10-Date-Time-API-JSR-310" class="headerlink" title="12.2.10 Date&#x2F;Time API(JSR 310)"></a>12.2.10 Date&#x2F;Time API(JSR 310)</h2><p>Java 8引入了新的Date-Time API(JSR 310)来改进时间、日期的处理。时间和日期的管理一直是最令Java 开发者痛苦的问题。java.util.Date和后来的java.util.Calendar一直没有解决这个问题（甚至令开发者更加迷茫）。</p>
<p>由上述原因，诞生了第三方库Joda-Time，可以替代Java的时间管理API。Java 8中新的时间和日期管理 API深受Joda-Time影响，并吸收了很多Joda-Time的精华。新的java.time包包含了所有关于日期、时间、时区、Instant（跟日期类似但是精确到纳秒）、duration（持续时间）和时钟操作的类。新设计的 API认真考虑了这些类的不变性（从java.util.Calendar吸取的教训），如果某个实例需要修改，则返回一个新的对象。</p>
<table><thead><tr><th>方法</th><th>描述</th></tr></thead><tr><td>now()</td><td>静态方法，根据当前时间创建对象</td></tr><tr><td>of()</td><td>静态方法，根据指定日期/时间创建 对象</td></tr><tr><td>plusDays, plusWeeks, plusMonths, plusYears</td><td>向当前 LocalDate 对象添加几天、 几周、几个月、 几年</td></tr><tr><td>minusDays, minusWeeks, minusMonths, minusYears</td><td>从当前 LocalDate 对象减去几天、 几周、几个月 几年</td></tr><tr><td>plus, minus</td><td>添加或减少一个 Duration或 Period</td></tr><tr><td>withDayOfMonth, withDayOfYear, withMonth, withYear</td><td>将月份天数、年份天数、月份、年 份修改为指定的 值并返回新的 LocalDate对象</td></tr><tr><td>getDayOfMonth</td><td>获得月份天数(1-31)</td></tr><tr><td>getDayOfYear</td><td>获得年份天数(1-366)</td></tr><tr><td>getDayOfWeek</td><td>获得星期几(返回一个 DayOfWeek 枚举值</td></tr><tr><td>getMonth</td><td>获得月份, 返回一个 Month枚举值</td></tr><tr><td>getMonthValue</td><td>获得月份(1-12)</td></tr><tr><td>getYear</td><td>获得年份</td></tr><tr><td>until</td><td>获得两个日期之间的 Period 对象，或者指定 ChronoUnits的数字</td></tr><tr><td>isBefore, isAfter</td><td>比较两个 LocalDate</td></tr><tr><td>isLeapYear</td><td>判断是否是闰年</td></tr></table>

<p>我们接下来看看java.time包中的关键类和各自的使用例子。</p>
<p>首先，Clock类使用时区来返回当前的纳秒时间和日期。Clock可以替代System.currentTimeMillis()和 TimeZone.getDefault()。</p>
<p>&#x2F;&#x2F; Get the system clock as UTC offset</p>
<p>final clock clock ( &#x3D; ) clock.systemUTC();</p>
<p>System.out.println( clock.instant());</p>
<p>System.out.println( clock.millis() );</p>
<p>输出的结果是:</p>
<p>2014-04-12T15:19:29.282Z</p>
<p>1397315969360</p>
<p>LocalDateTime类包含了LocalDate和LocalTime的信息，但是不包含ISO-8601日历系统中的时区信息。 这里有一些关于LocalDate和LocalTime的例子:</p>
<p>&#x2F;&#x2F; Get the local date&#x2F;time</p>
<p>final LocalDateTime datetime ( &#x3D; ) LocalDateTime.now();</p>
<p>final LocalDateTime datetimeFromClock &#x3D; LocalDateTime.now( clock );</p>
<p>System.out.println( datetime );</p>
<p>System.out.println( datetimeFromClock );</p>
<p>输出的结果是:</p>
<p>2014-04-12T11:37:52.309</p>
<p>2014-04-12T15:37:52.309</p>
<p>最后看下Duration类，它持有的时间精确到秒和纳秒。这使得我们可以很容易得计算两个日期之间的不同，例子代码如下:</p>
<p>&#x2F;&#x2F; Get duration between two dates</p>
<p>final LocalDateTime from &#x3D; LocalDateTime.of( 2014, Month.APRIL, 16, 0, 0, 0 );</p>
<p>final LocalDateTime to ( &#x3D; ) LocalDateTime.of( 2015, Month.APRIL, 16, 23, 59, 59);</p>
<p>final Duration duration ( &#x3D; ) Duration.between( from, to );</p>
<p>System.out.println( “Duration in days: “ + duration.toDays() );</p>
<p>System.out.println( “Duration in hours: “ + duration.toHours() );</p>
<p>这个例子用于计算2014年4月16日和2015年4月16日之间的天数和小时数，输出结果如下：</p>
<p>Duration in days: 365</p>
<p>Duration in hours: 8783</p>
<p>对于Java 8的新日期时间的总体印象还是比较积极的，一部分是因为Joda-Time的积极影响，另一部分是因为官方终于听取了开发人员的需求。</p>
<h2 id="12-2-11-Base64"><a href="#12-2-11-Base64" class="headerlink" title="12.2.11 Base64"></a>12.2.11 Base64</h2><p>对Base64编码的支持已经被加入到Java 8官方库中，这样不需要使用第三方库就可以进行Base64编码， 例子代码如下:</p>
<p>package com.javacodegeeks.java8.base64;</p>
<p>import java.nio.charset.StandardCharsets;</p>
<p>import java.util.Base64;</p>
<p>public class Base64s {</p>
<p>public static void main(String[] args) {</p>
<p>final String text &#x3D; “Base64 finally in Java 8!”;</p>
<p>final String encoded ( &#x3D; ) Base64</p>
<p>.getEncoder()</p>
<p>.encodeToString( text.getBytes( StandardCharsets.UTF_8 ) );</p>
<p>System.out.println( encoded );</p>
<p>final string decoded ( &#x3D; ) new String(</p>
<p>Base64.getDecoder().decode( encoded ),</p>
<p>StandardCharsets.UTF_8 );</p>
<p>System.out.println( decoded ); } }</p>
<p>这个例子的输出结果如下:</p>
<p>QmFzZTY0IGZpbmFsbHkgaw4gSmF2YSA4IQ&#x3D;&#x3D;</p>
<p>Base64 finally in Java 8!</p>
<p>新的Base64API也支持URL和MINE的编码解码。</p>
<p>(Base64.getUrlEncoder() &#x2F; Base64.getUrlDecoder(), Base64.getMimeEncoder() &#x2F;</p>
<p>Base64.getMimeDecoder())。</p>
<h2 id="12-2-12-Nashorn-JavaScript引擎"><a href="#12-2-12-Nashorn-JavaScript引擎" class="headerlink" title="12.2.12 Nashorn JavaScript引擎"></a>12.2.12 Nashorn JavaScript引擎</h2><p>Java 8提供了新的Nashorn JavaScript引擎，使得我们可以在JVM上开发和运行JS应用。Nashorn</p>
<p>JavaScript引擎是javax.script.ScriptEngine的另一个实现版本，这类Script引擎遵循相同的规则，允许 Java和JavaScript交互使用，例子代码如下:</p>
<p>ScriptEngineManager manager &#x3D; new ScriptEngineManager();</p>
<p>ScriptEngine engine &#x3D; manager.getEngineByName(“JavaScript”);</p>
<p>System.out.println( engine.getClass().getName());</p>
<p>System.out.println(“Result:” + engine.eval(“function ( f\left( \right) { ) return ( 1;} ;f\left( \right) + )</p>
<p>1;” ) );</p>
<p>这个代码的输出结果如下:</p>
<p>jdk.nashorn.api.scripting.NashornScriptEngine</p>
<p>Result: 2</p>
<h2 id="12-2-13-并行数组"><a href="#12-2-13-并行数组" class="headerlink" title="12.2.13 并行数组"></a>12.2.13 并行数组</h2><p>Java8版本新增了很多新的方法，用于支持并行数组处理。最重要的方法是parallelSort()，可以显著加快多核机器上的数组排序。下面的例子论证了parallexXxx系列的方法：</p>
<p>package com.javacodegeeks.java8.parallel.arrays;</p>
<p>import java.util.Arrays;</p>
<p>import java.util.concurrent.ThreadLocalRandom;</p>
<p>public class ParallelArrays {</p>
<p>public static void main( String[] args ) {</p>
<p>long[] arrayOfLong &#x3D; new long [ 20000 ];</p>
<p>Arrays.parallelSetAll(arrayOfLong,</p>
<p>index -&gt; ThreadLocalRandom.current().nextInt( 1000000 );</p>
<p>Arrays.stream( arrayOfLong ).limit( 10 ).forEach(</p>
<p>i -&gt; System.out.print( i + “ “ ) );</p>
<p>System.out.println();</p>
<p>Arrays.parallelSort( arrayOfLong );</p>
<p>Arrays.stream( arrayOfLong ).limit( 10 ).forEach(</p>
<p>i -&gt; System.out.print( i + “ “ ) );</p>
<p>System.out.println(); } }</p>
<p>上述这些代码使用parallelSetAll()方法生成20000个随机数，然后使用parallelSort()方法进行排序。这个程序会输出乱序数组和排序数组的前10个元素。上述例子的代码输出的结果是:</p>
<p>Unsorted: 591217 891976 443951 424479 766825 351964 242997 642839 119108 552378</p>
<p>Sorted: 39 220 263 268 325 607 655 678 723 793</p>
<h2 id="12-2-14-并发性"><a href="#12-2-14-并发性" class="headerlink" title="12.2.14 并发性"></a>12.2.14 并发性</h2><p>基于新增的lambda表达式和steam特性，为Java 8中为java.util.concurrent.Concurrent.HashMap类添加了新的方法来支持聚焦操作；另外，也为java.util.concurrentForkjoinPool类添加了新的方法来支持通用线程池操作（更多内容可以参考我们的并发编程课程）。</p>
<p>Java 8还添加了新的java.util.concurrent.locks.StampedLock类，用于支持基于容量的锁——该锁有三个模型用于支持读写操作（可以把这个锁当做是java.util.concurrent.locks.ReadWriteLock的替代者）。</p>
<p>在java.util.concurrent.atomic包中也新增了不少工具类，列举如下:</p>
<p>DoubleAccumulator</p>
<p>DoubleAdder</p>
<p>LongAccumulator</p>
<p>LongAdder</p>
<h2 id="12-2-15-JVM的新特性"><a href="#12-2-15-JVM的新特性" class="headerlink" title="12.2.15 JVM的新特性"></a>12.2.15 JVM的新特性</h2><p>使用Metaspace (JEP 122) 代替持久代 (PermGen space) 。在JVM参数方面，使用-</p>
<p>XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。</p>
<p>距JAVA 8更行已有数年之久，现在的学习者大多在一开始就已经适应了JAVA 8 的新特性，如果想要了解更多关于JAVA 8新特性的细节一定要浏览官网文档哦~！！！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://lypsblog.top">实名上网陆熠鹏</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://lypsblog.top/2024/06/26/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">http://lypsblog.top/2024/06/26/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/img/java/java.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/26/Pytorch7%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97/" title="Pytorch7深度学习计算"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/pytorch.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">Pytorch7深度学习计算</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/23/C-%E5%9B%BE%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/" title="C++图学习整理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cpp/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next</div><div class="next_info">C++图学习整理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/06/17/git%E8%AF%A6%E8%A7%A3/" title="git详解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/git.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-17</div><div class="title">git详解</div></div></a></div><div><a href="/2024/06/30/Java%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/" title="Java容器用法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-30</div><div class="title">Java容器用法</div></div></a></div><div><a href="/2024/09/06/Springboot%E7%AE%80%E5%8D%95%E5%9B%9E%E9%A1%BE/" title="Springboot简单回顾"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/springboot.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-06</div><div class="title">Springboot简单回顾</div></div></a></div><div><a href="/2024/08/12/Flexbox%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90/" title="Flexbox弹性盒子"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-12</div><div class="title">Flexbox弹性盒子</div></div></a></div><div><a href="/2024/09/12/mysql%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/" title="Mysql常用方法整理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-12</div><div class="title">Mysql常用方法整理</div></div></a></div><div><a href="/2024/09/28/%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE-Springboot%E5%9B%9E%E9%A1%BEDay3/" title="外卖项目--Springboot回顾Day3"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/springboot.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-28</div><div class="title">外卖项目--Springboot回顾Day3</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">实名上网陆熠鹏</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lyp6666666"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lyp6666666" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:532567840@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://leetcode.cn/u/frosty-boydw85/" target="_blank" title="LeetCode"><i class="fas fa-code"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Welcome to my blog !</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Java-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3"><span class="toc-text">1. Java 数据类型详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.1 基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%8C%85%E8%A3%85%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.2 包装数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.3 引用类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">1.4 数据类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="toc-text">1.5 缓存池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Java-%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3"><span class="toc-text">2. Java 关键字详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Java-%E5%85%B3%E9%94%AE%E5%AD%97%E6%B1%87%E6%80%BB"><span class="toc-text">2.1 Java 关键字汇总</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-final-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">2.2 final 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-1-final-%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="toc-text">2.2.1 final 修饰类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-2-final-%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="toc-text">2.2.2 final 修饰方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-3-final-%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="toc-text">2.2.3 final 修饰变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">2.3 static 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-1-static-%E5%8F%98%E9%87%8F"><span class="toc-text">2.3.1 static 变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-2-static-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">2.3.2 static 代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-this-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">2.4 this 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-1-%E5%BC%95%E7%94%A8%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">2.4.1 引用成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-2-%E8%B0%83%E7%94%A8%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E6%96%B9%E6%B3%95"><span class="toc-text">2.4.2 调用类的构造器方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-3-%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-text">2.4.3 返回对象的引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Java%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3"><span class="toc-text">3. Java的三大特性详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%B0%81%E8%A3%85"><span class="toc-text">3.1 封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-1-public%E3%80%81private%E3%80%81protected%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">3.1.1 public、private、protected修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-2-%E8%A7%84%E8%8C%83"><span class="toc-text">3.1.2 规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-3-%E5%B0%81%E8%A3%85%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">3.1.3 封装的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E7%BB%A7%E6%89%BF"><span class="toc-text">3.2 继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-1-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-text">3.2.1 继承的初始化顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-2-%E7%BB%A7%E6%89%BF%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.2.2 继承示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%A4%9A%E6%80%81"><span class="toc-text">3.3 多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-1-%E5%A4%9A%E6%80%81%E6%A6%82%E5%BF%B5"><span class="toc-text">3.3.1 多态概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-2-%E5%A4%9A%E6%80%81%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-text">3.3.2 多态要注意的细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-3-%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">3.3.3 多态的应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Java-%E4%B8%AD%E7%9A%84-String-%E8%AF%A6%E8%A7%A3"><span class="toc-text">4. Java 中的 String 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E7%9C%8B%E7%9C%8B%E6%BA%90%E7%A0%81"><span class="toc-text">4.1 看看源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%E5%91%A2"><span class="toc-text">4.2 不可变有什么好处呢</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-1-%E5%8F%AF%E4%BB%A5%E7%BC%93%E5%AD%98-hash-%E5%80%BC"><span class="toc-text">4.2.1 可以缓存 hash 值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-2-String-Pool-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">4.2.2 String Pool 的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-3-%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">4.2.3 安全性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-4-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">4.2.4 线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%86%8D%E6%9D%A5%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B-String"><span class="toc-text">4.3 再来深入了解一下 String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-1-%E2%80%9C-%E2%80%9D-%E8%BF%9E%E6%8E%A5%E7%AC%A6"><span class="toc-text">4.3.1 “+” 连接符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-2-%E2%80%9C-%E2%80%9D%E8%BF%9E%E6%8E%A5%E7%AC%A6%E7%9A%84%E6%95%88%E7%8E%87"><span class="toc-text">4.3.2 “+”连接符的效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="toc-text">4.4 字符串常量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-StringBuffer-%E5%92%8C-StringBuilder-%E8%AF%A6%E8%A7%A3"><span class="toc-text">5. StringBuffer 和 StringBuilder 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-text">5.1 相同点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-text">5.2 不同点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Java-%E5%8F%8D%E5%B0%84%E8%AF%A6%E8%A7%A3"><span class="toc-text">6. Java 反射详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%8F%8D%E5%B0%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">6.1 反射是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86%E5%A4%A7%E8%A7%A3%E6%9E%90"><span class="toc-text">6.2 反射原理大解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-1-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-text">6.2.1 反射的常用类和函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-2-Class-%E7%B1%BB%E5%8C%85%E5%90%AB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">6.2.2 Class 类包含的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-3-%E5%8F%8D%E5%B0%84%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-text">6.2.3 反射的主要方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-3-1-%E5%BE%97%E5%88%B0%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">6.2.3.1 得到构造器的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-3-2-%E8%8E%B7%E5%BE%97%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">6.2.3.2 获得字段信息的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-3-3-%E8%8E%B7%E5%BE%97%E6%96%B9%E6%B3%95%E4%BF%A1%E6%81%AF%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">6.2.3.3 获得方法信息的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-4-%E5%8F%8D%E5%B0%84%E5%AE%9E%E6%88%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-text">6.2.4 反射实战的基本步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-4-1-%E8%8E%B7%E5%BE%97%E7%B1%BB%E7%9A%84Class%E5%AF%B9%E8%B1%A1"><span class="toc-text">6.2.4.1 获得类的Class对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-4-2-%E8%8E%B7%E5%8F%96-Method-%E5%AF%B9%E8%B1%A1"><span class="toc-text">6.2.4.2 获取 Method 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-4-3-%E8%B0%83%E7%94%A8invoke-%E6%96%B9%E6%B3%95"><span class="toc-text">6.2.4.3 调用invoke()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-Java%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8-Hibernate%E6%A1%86%E6%9E%B6"><span class="toc-text">6.3 Java反射的应用(Hibernate框架)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Java-%E5%BC%82%E5%B8%B8%E8%AF%A6%E8%A7%A3"><span class="toc-text">7. Java 异常详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">7.1 异常的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-Java-%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%88%86%E4%B8%BA%E5%93%AA%E4%BA%9B%E7%A7%8D%E7%B1%BB"><span class="toc-text">7.2 Java 中异常分为哪些种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-error-%E5%92%8Cexception-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">7.3 error 和exception 有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-throw-%E5%92%8C-throws-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">7.4 throw 和 throws 的区别是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-Java-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-text">7.5 Java 的异常处理机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E8%AF%B7%E5%86%99%E5%87%BA%E4%BD%A0%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%845-%E4%B8%AARuntimeException"><span class="toc-text">7.6 请写出你最常见的5 个RuntimeException</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-final%E3%80%81finally%E3%80%81finalize-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7.7 final、finally、finalize 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-NoClassDefFoundError-%E5%92%8C-ClassNotFoundException-%E5%8C%BA%E5%88%AB"><span class="toc-text">7.8 NoClassDefFoundError 和 ClassNotFoundException 区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Java-IO-%E6%B5%81%E8%AF%A6%E8%A7%A3"><span class="toc-text">8. Java IO 流详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-Java-IO%E6%A6%82%E5%BF%B5"><span class="toc-text">8.1 Java IO概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-Java-IO%E6%B5%81%E5%88%86%E7%B1%BB"><span class="toc-text">8.2 Java IO流分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-Java-IO%E6%B5%81%E7%89%B9%E6%80%A7"><span class="toc-text">8.3 Java IO流特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-Java-IO%E6%B5%81%E6%8E%A5%E5%8F%A3"><span class="toc-text">8.4 Java IO流接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-Java-IO%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="toc-text">8.5 Java IO流对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-1-%E8%BE%93%E5%85%A5%E5%AD%97%E8%8A%82%E6%B5%81InputStream"><span class="toc-text">8.5.1 输入字节流InputStream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-2-%E8%BE%93%E5%87%BA%E5%AD%97%E8%8A%82%E6%B5%81OutputStream"><span class="toc-text">8.5.2 输出字节流OutputStream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-3-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81-Reader"><span class="toc-text">8.5.3 字符输入流 Reader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-4-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81Writer"><span class="toc-text">8.5.4 字符输出流Writer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-Java-IO%E6%B5%81%E6%96%B9%E6%B3%95"><span class="toc-text">8.6 Java IO流方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-1-%E5%AD%97%E8%8A%82%E6%B5%81%E6%96%B9%E6%B3%95"><span class="toc-text">8.6.1 字节流方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-2-%E5%AD%97%E7%AC%A6%E6%B5%81%E6%96%B9%E6%B3%95"><span class="toc-text">8.6.2 字符流方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">8.7 字节流与字符流的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8-%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8.8 字节流与字符流的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-9-%E5%B0%8F%E7%BB%93"><span class="toc-text">8.9 小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-Java-%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3"><span class="toc-text">9. Java 注解详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%A8%E8%A7%A3"><span class="toc-text">9.1 什么是注解?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E5%85%83%E6%B3%A8%E8%A7%A3%E6%8E%A2%E7%A7%98"><span class="toc-text">9.2 元注解探秘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-1-Target"><span class="toc-text">9.2.1 Target</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-2-Inherited"><span class="toc-text">9.2.2 @Inherited</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text">&#x2F;*自定义注解&#x2F;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-3-Retention"><span class="toc-text">9.2.3 @Retention</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-4-Documented"><span class="toc-text">9.2.4 @Documented</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-5-Repeatable"><span class="toc-text">9.2.5 @Repeatable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E6%B3%A8%E8%A7%A3%E5%B1%9E%E6%80%A7%E7%9F%A5%E5%A4%9A%E5%B0%91"><span class="toc-text">9.3 注解属性知多少</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text">9. 自定义注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-1-%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">9.4.1 注解的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-2-%E6%B3%A8%E8%A7%A3%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B"><span class="toc-text">9.4.2 注解属性类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-3-%E4%B8%BA%E6%B3%A8%E8%A7%A3%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC"><span class="toc-text">9.4.3 为注解成员变量赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-4-%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">9.4.4 获取注解的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-JDK%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-text">9.5 JDK提供的注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%BF%90%E7%94%A8"><span class="toc-text">9.6 注解的运用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-7-%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">9.7 注解的意义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-Java-%E6%B3%9B%E5%9E%8B"><span class="toc-text">10. Java 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%8F%90%E5%87%BA%EF%BC%9F"><span class="toc-text">10.1 泛型的提出？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-text">10.2 常用的泛型类型变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">10.3 泛型的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-0-3-1-%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-text">1.0.3.1 泛型类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E6%A1%88%E4%BE%8B%E5%85%B7%E4%BD%93%E5%8C%96"><span class="toc-text">将案例具体化:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E6%98%AF"><span class="toc-text">值得注意的是:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-2-%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">10.3.2 泛型接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-3-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">10.3.3 泛型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-3-1-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">10.3.3.1 泛型方法的基本用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-3-2-%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">10.3.3.2 类中的泛型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-3-3-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E6%B3%9B%E5%9E%8B"><span class="toc-text">10.3.3.3 静态方法与泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">10.4 泛型通配符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%81%E8%AF%B4%E4%B8%89%E9%81%8D"><span class="toc-text">要说三遍!</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-%E6%B3%9B%E5%9E%8B%E4%B8%8A%E4%B8%8B%E8%BE%B9%E7%95%8C"><span class="toc-text">10.5 泛型上下边界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6-%E6%B3%9B%E5%9E%8B%E5%AD%98%E5%9C%A8%E7%9A%84%E7%BA%A6%E6%9D%9F"><span class="toc-text">10.6 泛型存在的约束</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-Java-%E6%9E%9A%E4%B8%BE"><span class="toc-text">11. Java 枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%9A%E4%B8%BE"><span class="toc-text">11.1 什么是枚举?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E5%A6%82%E4%BD%95%E5%A3%B0%E6%98%8E%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">11.2 如何声明枚举类型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E4%B8%BA"><span class="toc-text">上述代码输出为:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-1-%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">11.2.1 枚举类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E4%BB%8E%E5%AE%87%E5%AE%99%E5%85%A5%E6%89%8B%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text">11.3 从宇宙入手深入了解枚举类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-EnumMap-%E4%B8%8E-EnumSet"><span class="toc-text">11.4 EnumMap 与 EnumSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EnumSet-%E7%B1%BB"><span class="toc-text">EnumSet 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">11.5 使用枚举类型的优势</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-Java-8-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">12. Java 8 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-Java-8-%E7%AE%80%E4%BB%8B"><span class="toc-text">12.1 Java 8 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-Java-8-%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3"><span class="toc-text">12.2 Java 8 特性详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-1-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">12.2.1 Lambda表达式和函数式接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-2-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">12.2.2 方法引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-3-%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">12.2.3 接口的默认方法和静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-4-%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-text">12.2.4 更好的类型推断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E5%88%97%E4%BB%A3%E7%A0%81%E6%98%AFValue%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">下列代码是Value类型的应用:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-5-%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3"><span class="toc-text">12.2.5 重复注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-6-%E6%8B%93%E5%B1%95%E6%B3%A8%E8%A7%A3"><span class="toc-text">12.2.6 拓展注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-7-Java%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">12.2.7 Java编译器的新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-8-Optional"><span class="toc-text">12.2.8 Optional</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-9-Streams"><span class="toc-text">12.2.9 Streams</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-10-Date-Time-API-JSR-310"><span class="toc-text">12.2.10 Date&#x2F;Time API(JSR 310)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-11-Base64"><span class="toc-text">12.2.11 Base64</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-12-Nashorn-JavaScript%E5%BC%95%E6%93%8E"><span class="toc-text">12.2.12 Nashorn JavaScript引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-13-%E5%B9%B6%E8%A1%8C%E6%95%B0%E7%BB%84"><span class="toc-text">12.2.13 并行数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-14-%E5%B9%B6%E5%8F%91%E6%80%A7"><span class="toc-text">12.2.14 并发性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-15-JVM%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">12.2.15 JVM的新特性</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/21/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%B8%A6%E4%BD%A0%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3Mysql%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6%EF%BC%81-%E5%B8%A6%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A1%A5%E5%85%85/" title="由浅入深带你快速理解Mysql内部机制！(带面试题补充)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="由浅入深带你快速理解Mysql内部机制！(带面试题补充)"/></a><div class="content"><a class="title" href="/2025/06/21/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%B8%A6%E4%BD%A0%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3Mysql%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6%EF%BC%81-%E5%B8%A6%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A1%A5%E5%85%85/" title="由浅入深带你快速理解Mysql内部机制！(带面试题补充)">由浅入深带你快速理解Mysql内部机制！(带面试题补充)</a><time datetime="2025-06-21T09:28:18.000Z" title="Created 2025-06-21 17:28:18">2025-06-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/21/JUC%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%87%E5%AD%97%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82JUC%EF%BC%89%E6%A1%86%E6%9E%B6%E5%BB%BA%E7%AB%8B%EF%BC%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E7%90%86%E8%A7%A3/" title="JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解"/></a><div class="content"><a class="title" href="/2025/06/21/JUC%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%87%E5%AD%97%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82JUC%EF%BC%89%E6%A1%86%E6%9E%B6%E5%BB%BA%E7%AB%8B%EF%BC%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E7%90%86%E8%A7%A3/" title="JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解">JUC详解（万字带你彻底搞懂JUC）框架建立＋面试题理解</a><time datetime="2025-06-21T08:23:25.000Z" title="Created 2025-06-21 16:23:25">2025-06-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/08/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="JVM知识点整理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM知识点整理"/></a><div class="content"><a class="title" href="/2025/05/08/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="JVM知识点整理">JVM知识点整理</a><time datetime="2025-05-08T12:35:10.000Z" title="Created 2025-05-08 20:35:10">2025-05-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/24/HashMap%E6%80%BB%E7%BB%93/" title="HashMap总结"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HashMap总结"/></a><div class="content"><a class="title" href="/2025/04/24/HashMap%E6%80%BB%E7%BB%93/" title="HashMap总结">HashMap总结</a><time datetime="2025-04-24T15:14:13.000Z" title="Created 2025-04-24 23:14:13">2025-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/java/%E7%BD%91%E7%BB%9C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2025/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2025-03-31T06:49:57.000Z" title="Created 2025-03-31 14:49:57">2025-03-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 实名上网陆熠鹏</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional Chinese And Simplified Chinese">简</button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>